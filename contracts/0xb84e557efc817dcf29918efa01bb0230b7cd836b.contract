{"IERC20.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    event Transfer(address indexed from,address indexed to,uint256 value);\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n}\r\n"},"IPancakeFactory.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n"},"IPancakeRouter.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\ninterface IPancakeRouter {\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.4;\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"},"TokenTemplate.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\nimport \u0027./IPancakeRouter.sol\u0027;\r\nimport \u0027./SafeMath.sol\u0027;\r\nimport \u0027./IERC20.sol\u0027;\r\nimport \u0027./IPancakeFactory.sol\u0027;\r\n\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    mapping (address =\u003e uint256) public _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) public _allowed;\r\n    uint256 public _totalSupply;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    function allowance(address owner,address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender,uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender,uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n        require(value \u003c= _balances[from]);\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract TokenTemplate is ERC20 {\r\n    string  private _name = \"TREE\";\r\n    string  private _symbol = \"TREE\";\r\n    uint8   private _decimals = 18;\r\n    address public pancakeToken = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address public usdtToken = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public pancakePair;\r\n    address public feeAddress;\r\n    address public LPAddress;\r\n\r\n    uint256 public  MAX_STOP_FEE_TOTAL = 3000 * 10 ** uint256(_decimals);\r\n\r\n    constructor (uint256 _initialAmount, address _feeAddress, address _LPAddress) public {\r\n        _totalSupply = _initialAmount.mul(10 ** uint256(_decimals));\r\n        feeAddress = _feeAddress;\r\n        LPAddress = _LPAddress;\r\n        _balances[msg.sender] = _initialAmount.mul(10 ** uint256(_decimals));\r\n        IPancakeRouter router =  IPancakeRouter(pancakeToken);\r\n        pancakePair =  IPancakeFactory(router.factory()).createPair(address(this), usdtToken);\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n     function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(value \u003c= _allowed[from][msg.sender]);\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n     function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n        require(value \u003c= _balances[from]);\r\n        if(_totalSupply \u003e MAX_STOP_FEE_TOTAL){\r\n            uint256 XHAmount = value.mul(2).div(100);\r\n            uint256 feeAmount = value.mul(1).div(100);\r\n            uint256 LPAmount = value.mul(5).div(1000);\r\n            if (from == pancakePair) {\r\n                _balances[from] = _balances[from].sub(value);\r\n                _balances[to] = _balances[to].add(value.sub(feeAmount + XHAmount + LPAmount));\r\n                _balances[feeAddress] = _balances[feeAddress].add(feeAmount);\r\n                _balances[LPAddress] = _balances[LPAddress].add(LPAmount);\r\n                emit Transfer(from, feeAddress, feeAmount);\r\n                emit Transfer(from, LPAddress, LPAmount);\r\n                emit Transfer(from, to, value.sub(feeAmount + XHAmount + LPAmount));\r\n            } else if(to == pancakePair) {\r\n                _balances[from] = _balances[from].sub(value + feeAmount + XHAmount + LPAmount);\r\n                _balances[to] = _balances[to].add(value);\r\n                _balances[feeAddress] = _balances[feeAddress].add(feeAmount);\r\n                _balances[LPAddress] = _balances[LPAddress].add(LPAmount);\r\n                emit Transfer(from, feeAddress, feeAmount);\r\n                emit Transfer(from, LPAddress, LPAmount);\r\n                emit Transfer(from, to, value);\r\n            }else {\r\n                _balances[from] = _balances[from].sub(value);\r\n                _balances[to] = _balances[to].add(value.sub(feeAmount + XHAmount));\r\n                _balances[feeAddress] = _balances[feeAddress].add(feeAmount);\r\n                emit Transfer(from, feeAddress, feeAmount);\r\n                emit Transfer(from, to, value.sub(feeAmount + XHAmount));\r\n            }\r\n            _burn(from, XHAmount);\r\n        }else{\r\n            uint256 feeAmount = value.mul(3).div(100);\r\n            uint256 LPAmount = value.mul(5).div(1000);\r\n            if (from == pancakePair) {\r\n                _balances[from] = _balances[from].sub(value);\r\n                _balances[to] = _balances[to].add(value.sub(feeAmount + LPAmount));\r\n                _balances[feeAddress] = _balances[feeAddress].add(feeAmount);\r\n                _balances[LPAddress] = _balances[LPAddress].add(LPAmount);\r\n                emit Transfer(from, feeAddress, feeAmount);\r\n                emit Transfer(from, LPAddress, LPAmount);\r\n                emit Transfer(from, to, value.sub(feeAmount + LPAmount));\r\n            } else if(to == pancakePair) {\r\n                _balances[from] = _balances[from].sub(value + feeAmount + LPAmount);\r\n                _balances[to] = _balances[to].add(value);\r\n                _balances[feeAddress] = _balances[feeAddress].add(feeAmount);\r\n                _balances[LPAddress] = _balances[LPAddress].add(LPAmount);\r\n                emit Transfer(from, feeAddress, feeAmount);\r\n                emit Transfer(from, LPAddress, LPAmount);\r\n                emit Transfer(from, to, value);\r\n            }else {\r\n                _balances[from] = _balances[from].sub(value);\r\n                _balances[to] = _balances[to].add(value.sub(feeAmount));\r\n                _balances[feeAddress] = _balances[feeAddress].add(feeAmount);\r\n                emit Transfer(from, feeAddress, feeAmount);\r\n                emit Transfer(from, to, value.sub(feeAmount));\r\n            }\r\n        }\r\n        \r\n    }\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0));\r\n        // _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n        require(account != address(0));\r\n    }\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\r\n"}}