// File: contracts/util/Context.sol

// SPDX-License-Identifier: MIT

pragma solidity 0.8.7;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: contracts/util/Ownable.sol



pragma solidity 0.8.7;


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
 abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// File: contracts/token/VIPLockToken.sol


pragma solidity 0.8.7;


abstract contract VIPLockToken is Ownable {

    struct vipLockedToken {
        uint256 lockedToken;
        uint256 unlockRegisteredTime;
        uint256 unlockAfter;
        uint256 unlockActualTime;
        bool unlocked;
        bool existed;
    }

    address public _locker;
    uint256 unlockAddedTime;
    uint256 relockVIPAddedTime;
    mapping(address => vipLockedToken) mappingAddressToVIPLock;

    // Event
    event VIPTokenLocked(address indexed account, uint256 amount);
    event VIPTokenUnlocked(address indexed account, uint256 amount);
    event VIPTokenUnlockRegisted(address account);
    event VIPLockerTransferred(
        address indexed previousLocker,
        address indexed newLocker
    );
    event VIPUnlockAddedTimeModified(
        uint256 indexed previousAddedTime,
        uint256 indexed newAddedTime
    );

    event VIPRelockAddedTimeModified(
        uint256 indexed previousAddedTime,
        uint256 indexed newAddedTime
    );

    modifier onlyLocker() {
        require(_locker == _msgSender(), "Caller is not the locker");
        _;
    }

    function transferLocker(address newLockerAddress)
        public
        onlyOwner
        returns (bool)
    {
        require(newLockerAddress != address(0));
        emit VIPLockerTransferred(_locker, newLockerAddress);
        _locker = newLockerAddress;
        return true;
    }

    function modifyUnlockAddedTime(uint256 newUnlockAddedTime)
        public
        onlyOwner
        returns (bool)
    {
        emit VIPUnlockAddedTimeModified(unlockAddedTime, newUnlockAddedTime);
        unlockAddedTime = newUnlockAddedTime;
        return true;
    }

    function modifyRelockVIPAddedTime(uint256 newRelockVIPAddedTime)
        public
        onlyOwner
        returns (bool)
    {
        emit VIPRelockAddedTimeModified(
            relockVIPAddedTime,
            newRelockVIPAddedTime
        );
        relockVIPAddedTime = newRelockVIPAddedTime;
        return true;
    }

    /** @dev Get `relockVIPAddedTime` that is added from time of unlock
     * token request action. After that time, user can do lock action again
     */
    function getRelockVIPAddedTime() public view returns (uint256) {
        return relockVIPAddedTime;
    }

    /** @dev Get `unlockAddedTime` that is added from time of unlock token request action
     */
    function getUnlockAddedTime() public view returns (uint256) {
        return unlockAddedTime;
    }

    /** @dev Current locked token of `address`
     */
    function currentVIPLockTokenOf(address account)
        public
        view
        returns (uint256)
    {
        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[
            account
        ];
        if (!vipLockOfAddress.existed) {
            return 0;
        }
        if (vipLockOfAddress.unlocked) {
            return 0;
        }
        if (
            vipLockOfAddress.unlockAfter > 0 &&
            vipLockOfAddress.unlockAfter <= block.timestamp
        ) {
            return 0;
        }
        return vipLockOfAddress.lockedToken;
    }

    /** @dev Lock `amount` of token for current sender
     */
    function vipLockToken(uint256 amount) public returns (bool) {
        _vipUnlock(_msgSender());
        bool done = _vipLock(_msgSender(), amount);
        require(done);
        return true;
    }

    /** @dev Lock `amount` of token for `account`
     */
    function _vipLock(address account, uint256 amount) internal returns (bool) {
        // check previous unlock time
        require(amount > 0);
        require(
            getAvailableBalance(account) >= amount,
            "Not enough unlocked tokens"
        );
        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[
            account
        ];
        if (vipLockOfAddress.existed) {
            require(vipLockOfAddress.unlocked, "Already has locked VIP");
            require(
                block.timestamp >=
                    vipLockOfAddress.unlockRegisteredTime + relockVIPAddedTime, "Await next lock VIP"
            );
        }
        mappingAddressToVIPLock[account] = vipLockedToken(
            amount,
            0,
            0,
            0,
            false,
            true
        );
        emit VIPTokenLocked(account, amount);
        return true;
    }

    /** @dev Get vip locked token info
     */
    function vipLockInfo(address account)
        public
        view
        returns (
            uint256,
            uint256,
            uint256,
            uint256,
            bool,
            bool
        )
    {
        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[
            account
        ];
        return (
            vipLockOfAddress.lockedToken,
            vipLockOfAddress.unlockRegisteredTime,
            vipLockOfAddress.unlockAfter,
            vipLockOfAddress.unlockActualTime,
            vipLockOfAddress.unlocked,
            vipLockOfAddress.existed
        );
    }

    /** @dev Register unlock vip token of sender
     */
    function vipUnlockRequest() public returns (bool) {
        address account = _msgSender();
        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[
            account
        ];
        require(vipLockOfAddress.existed  && 
          !vipLockOfAddress.unlocked &&
          vipLockOfAddress.unlockAfter == 0 && 
          vipLockOfAddress.unlockRegisteredTime  == 0,"Not valid unlock request");
        vipLockOfAddress.unlockAfter = block.timestamp + unlockAddedTime;
        vipLockOfAddress.unlockRegisteredTime = block.timestamp;
        mappingAddressToVIPLock[account] = vipLockOfAddress;
        if (unlockAddedTime == 0) {
            return _vipUnlock(account);
        }
        emit VIPTokenUnlockRegisted(account);
        return true;
    }

    /** @dev Unlock vip locked token for `account`
     */
    function _vipUnlock(address account) internal returns (bool) {
        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[
            account
        ];
        if (
            !vipLockOfAddress.existed ||
            vipLockOfAddress.unlocked ||
            vipLockOfAddress.unlockAfter == 0 ||
            block.timestamp < vipLockOfAddress.unlockAfter
        ) {
            return false;
        }
        vipLockOfAddress.unlocked = true;
        vipLockOfAddress.lockedToken = 0;
        vipLockOfAddress.unlockActualTime = block.timestamp;
        mappingAddressToVIPLock[account] = vipLockOfAddress;
        emit VIPTokenUnlocked(account, vipLockOfAddress.lockedToken);
        return true;
    }

    /** @dev Get current balance for vip lock token action of `account`
     */
    function getAvailableBalance(address account)
        public
        view
        virtual
        returns (uint256);
}

// File: contracts/token/IBEP20.sol


pragma solidity ^0.8.0;

/**
 * @dev Interface of the BEP20 standard. Does not include
 * the optional functions; to access them see {BEP20Detailed}.
 */
interface IBEP20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: contracts/util/Pausable.sol



pragma solidity 0.8.7;


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool private paused = false;


  /**
  * @dev modifier to allow actions only when the contract IS paused
  */
  modifier whenNotPaused() {
    require (!paused);
    _;
  }

  /**
  * @dev modifier to allow actions only when the contract IS NOT paused
  */
  modifier whenPaused {
    require (paused);
    _;
  }

  /**
  * @dev called by the owner to pause, triggers stopped state
  */
  function pause() onlyOwner external whenNotPaused returns (bool) {
    paused = true;
    emit Pause();
    return true;
  }

  /**
  * @dev called by the owner to unpause, returns to normal state
  */
  function unpause() onlyOwner external whenPaused returns (bool) {
    paused = false;
    emit Unpause();
    return true;
  }
}

// File: contracts/util/SafeMath.sol


pragma solidity 0.8.7;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: contracts/token/BEP20.sol


pragma solidity ^0.8.0;




contract BEP20 is Context, IBEP20, Pausable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IBEP20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IBEP20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IBEP20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public override virtual whenNotPaused returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IBEP20-allowance}.
     */
    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IBEP20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) external whenNotPaused override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IBEP20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {BEP20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public whenNotPaused override virtual returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IBEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) external whenNotPaused returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IBEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) external whenNotPaused returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "BEP20: transfer from the zero address");
        require(recipient != address(0), "BEP20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "BEP20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "BEP20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "BEP20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "BEP20: approve from the zero address");
        require(spender != address(0), "BEP20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "BEP20: burn amount exceeds allowance"));
    }
}

// File: contracts/token/SavingToken.sol


pragma solidity 0.8.7;



abstract contract SavingToken is Ownable {
    struct SavingItem {
        uint256 savingAmount;
        uint8 periodPlan;
        uint256 createdTime;
        uint256 expectedReleaseTime;
        uint256 resavingTime;
        uint256 savingRate;
        bool autoResaving;
        address savingOwner;
    }

    struct SavingInterestRate {
        uint256 rate;
        bool existed;
    }
    mapping(address => mapping(uint256 => SavingItem)) mappingSavingIDToDetail;
    mapping(address => uint256) mappingAdressToSavingTotal;
    mapping(uint8 => SavingInterestRate) mappingPeriodPlanToRate;
    bool _savingPaused;
    address private _savingOperator;

    event SavingEarlyClosed(
        address account,
        uint256 savingID,
        uint256 closeTime,
        uint256 expectedReleaseTime
    );

    event SavingOperatorTransferred(
        address indexed previousOperator,
        address indexed newOperator
    );

    event AutoResavingConfigured(
        address indexed account,
        uint256 indexed savingID,
        bool indexed autoResaving
    );

    event SavingRatesOverrided(uint8[] _periods, uint256[] _rates);

    event SavingCreated(address account, uint256 savingID);
    event SavingPaymentProcessed(uint256[] savingIDs, uint256 totalInterests);
    event SavingFeaturePaused(uint256 pausedTime);
    event SavingFeatureUnPaused(uint256 unpausedTime);

    modifier onlySavingOperator() {
        require(_savingOperator == _msgSender());
        _;
    }

    modifier notPaused() {
        require(!_savingPaused);
        _;
    }

    /** @dev Transfer saving operator address to new one `account` by owner of token
     */
    function transferSavingOperator(address account)
        public
        onlyOwner
        returns (bool)
    {
        require(account != address(0));
        emit SavingOperatorTransferred(_savingOperator, account);
        _savingOperator = account;
        return true;
    }

    /** @dev Get saving info of `account` and `savingID`
     */
    function savingInfo(address account, uint256 savingID)
        public
        view
        returns (SavingItem memory)
    {
        return mappingSavingIDToDetail[account][savingID];
    }

    /** @dev Set paused mode for saving feature by `savingPaused`
     */
    function savingFeaturePausedMode(bool savingPaused) public onlyOwner {
        _savingPaused = savingPaused;
        if (_savingPaused) {
            emit SavingFeaturePaused(block.timestamp);
            return;
        }
        emit SavingFeatureUnPaused(block.timestamp);
    }

    /** @dev Override rates with `_periodPlans` mapping to `_rates`
     */
    function overrideRates(
        uint8[] calldata _periodPlans,
        uint256[] calldata _rates
    ) external onlyOwner {
        require(_periodPlans.length == _rates.length);
        for (uint8 i = 0; i < _periodPlans.length; i++) {
            mappingPeriodPlanToRate[_periodPlans[i]] = SavingInterestRate(
                _rates[i],
                true
            );
        }
        emit SavingRatesOverrided(_periodPlans, _rates);
    }

    function getSavingRate(uint8 periodPlan) public view returns (uint256) {
        return mappingPeriodPlanToRate[periodPlan].rate;
    }

    /** @dev Current total saving token of `account`
     */
    function currentSavingTokenOf(address account)
        public
        view
        returns (uint256)
    {
        return mappingAdressToSavingTotal[account];
    }

    /** @dev Balance token of `account`
     */
    function getAvailableBalance(address account)
        public
        virtual
        returns (uint256);

    /** @dev Create saving  with `amount`, `_periodPlan`, `_autoResaving`, `_expectedReleaseTime`
     * and `savingID` by account
     */
    function createSaving(
        uint256 _amount,
        uint8 _periodPlan,
        bool _autoResaving,
        uint256 savingID
    ) public notPaused {
        address account = _msgSender();
        require(_amount != 0);
        require(getAvailableBalance(account) >= _amount, "Insufficient amount");
        require(mappingPeriodPlanToRate[_periodPlan].existed, "Not existed period");
        require(mappingSavingIDToDetail[account][savingID].savingAmount == 0, "Existed SavingID");
        mappingSavingIDToDetail[account][savingID] = SavingItem(
            _amount,
            _periodPlan,
            block.timestamp,
            block.timestamp +  (_periodPlan * 1 days),
            0,
            mappingPeriodPlanToRate[_periodPlan].rate,
            _autoResaving,
            account
        );
        mappingAdressToSavingTotal[account] =
            mappingAdressToSavingTotal[account] +
            _amount;
        emit SavingCreated(account, savingID);
    }

    /** @dev Early close saving by `savingID` from account
     */
    function earlyCloseSaving(uint256 savingID) public notPaused {
        address account = _msgSender();
        require(mappingSavingIDToDetail[account][savingID].savingAmount != 0);
        require(
            mappingSavingIDToDetail[account][savingID].expectedReleaseTime >
                block.timestamp
        );
        mappingAdressToSavingTotal[account] =
            mappingAdressToSavingTotal[account] -
            mappingSavingIDToDetail[account][savingID].savingAmount;
        uint256 expectedReleaseTime =  mappingSavingIDToDetail[account][savingID].expectedReleaseTime;
        delete mappingSavingIDToDetail[account][savingID];
        emit SavingEarlyClosed(account, savingID, block.timestamp,expectedReleaseTime);
    }

    function configureAutoResaving(uint256 savingID, bool autoResaving)
        public
        returns (bool)
    {
        address account = _msgSender();
        require(mappingSavingIDToDetail[account][savingID].savingAmount != 0 , "Not Existed SavingID");
        mappingSavingIDToDetail[account][savingID].autoResaving = autoResaving;
        emit AutoResavingConfigured(account, savingID, autoResaving);
        return true;
    }

    /** @dev Transfer interest and reautosaving for `savingIDs` and `accounts`
     * with `interests`
     */
    function processSaving(
        uint256[] calldata savingIDs,
        address[] calldata accounts
    ) external onlySavingOperator {
        require(savingIDs.length == accounts.length);
        uint256 totalInterests = 0;
        for (uint8 i = 0; i < savingIDs.length; i++) {
            address account = accounts[i];
            SavingItem memory savingItem = mappingSavingIDToDetail[account][
                savingIDs[i]
            ];
            if (savingItem.autoResaving) {
                savingItem.resavingTime = block.timestamp;
                savingItem.expectedReleaseTime =
                    block.timestamp + 
                    (savingItem.periodPlan *
                    1 days);
                savingItem.savingRate = mappingPeriodPlanToRate[
                    savingItem.periodPlan
                ].rate;
                mappingSavingIDToDetail[account][savingIDs[i]] = savingItem;
            }
            if (!savingItem.autoResaving) {
                mappingAdressToSavingTotal[account] =
                    mappingAdressToSavingTotal[account] -
                    savingItem.savingAmount;
                delete mappingSavingIDToDetail[account][savingIDs[i]];
            }
            uint256 interest = calculateSavingInterest(
                savingItem.savingAmount,
                savingItem.periodPlan,
                savingItem.savingRate
            );
            bool done = BEP20(address(this)).transfer(accounts[i], interest);
            require(done, "Failed tranfer");
            totalInterests += interest;
        }
        emit SavingPaymentProcessed(savingIDs, totalInterests);
    }

    function getTokenDecimal() internal view virtual returns (uint8);

    function calculateSavingInterest(
        uint256 savingAmount,
        uint8 savingPeriodPlan,
        uint256 savingRate
    ) public view returns (uint256) {
        return
            (savingAmount * savingPeriodPlan * savingRate) /
            (10**uint256(getTokenDecimal()));
    }
}

// File: contracts/token/BEP20Detailed.sol


pragma solidity ^0.8.0;


/**
 * @dev Optional functions from the BEP20 standard.
 */
abstract contract BEP20Detailed is IBEP20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of
     * these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) {
        _name = tokenName;
        _symbol = tokenSymbol;
        _decimals = tokenDecimals;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IBEP20-balanceOf} and {IBEP20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}

// File: contracts/token/TimeLockedToken.sol


pragma solidity 0.8.7;




abstract contract TimeLockedToken is BEP20Detailed, BEP20 {

    struct ScheduleLock {
        uint256 unlockTime;
        uint256 amount;
    }
    struct TimeLockByAddress {
        uint256 nextIndexTimeLock;
        uint256 totalLock;
        ScheduleLock[] arrTimeLock;
    }

    address public _manager;
    mapping(address => TimeLockByAddress) mappingAddressToLock;
    event TokenUnlocked(address indexed addressLock, uint256 amount);
    event AddressLockItemAdded(address indexed addressLock, uint256 amount);

    event ManagerTransferred(
        address indexed previousManager,
        address indexed newManager
    );

    modifier onlyManager() {
        require(_manager == _msgSender(), "Caller is not the Manager");
        _;
    }

    constructor(
        string memory _tokenName,
        string memory _tokenSymbol,
        uint256 _totalSupply
    ) BEP20Detailed(_tokenName, _tokenSymbol, 18) Ownable() {
        _mint(_msgSender(), _totalSupply * 10**uint256(18));
    }

    /**
     * @dev add lock amount and unlock time of address. Append at the end of array
     */
    function _addScheduleLockByAddress(
        address _addressLock,
        uint256 _unlockTime,
        uint256 _amount
    ) internal {
        mappingAddressToLock[_addressLock].arrTimeLock.push(
            ScheduleLock(_unlockTime, _amount)
        );
    }

    /**
     * @dev Update the next index for unlock item, total lock of address
     */
    function _updateTotalLockByAddress(
        address _addressLock,
        uint256 _totalLock,
        uint256 _nextIndexLock
    ) internal {
        mappingAddressToLock[_addressLock].nextIndexTimeLock = _nextIndexLock;
        mappingAddressToLock[_addressLock].totalLock = _totalLock;
        emit AddressLockItemAdded(_addressLock, _totalLock);
    }

    /**
     * @dev Unlock token of "_addressLock" with timeline lock
     */
    function _unLockTimeLockedToken(address _addressLock) internal {
        if (mappingAddressToLock[_addressLock].totalLock == 0) {
            return;
        }
        TimeLockByAddress memory timeLockByAddress = mappingAddressToLock[
            _addressLock
        ];
        uint256 totalUnlock = 0;
        while (
            timeLockByAddress.nextIndexTimeLock <
            timeLockByAddress.arrTimeLock.length &&
            block.timestamp >=
            timeLockByAddress
                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]
                .unlockTime
        ) {
            emit TokenUnlocked(
                _addressLock,
                timeLockByAddress
                    .arrTimeLock[timeLockByAddress.nextIndexTimeLock]
                    .amount
            );
            totalUnlock += timeLockByAddress
                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]
                .amount;
            timeLockByAddress.nextIndexTimeLock += 1;
        }
        if (totalUnlock > 0) {
            _updateTotalLockByAddress(
                _addressLock,
                timeLockByAddress.totalLock - totalUnlock,
                timeLockByAddress.nextIndexTimeLock
            );
        }
    }

    /**
     * @dev get total amount lock of address
     */
    function getLockedAmount(address _addressLock)
        public
        view
        returns (uint256 amount)
    {
        return mappingAddressToLock[_addressLock].totalLock;
    }

    /**
     * @dev get next shedule unlock time of address lock
     */
    function getNextScheduleUnlock(address _addressLock)
        public
        view
        returns (
            uint256 index,
            uint256 unlockTime,
            uint256 amount
        )
    {
        TimeLockByAddress memory timeLockByAddress = mappingAddressToLock[
            _addressLock
        ];
        return (
            timeLockByAddress.nextIndexTimeLock,
            timeLockByAddress
                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]
                .unlockTime,
            timeLockByAddress
                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]
                .amount
        );
    }

    /**
     * @dev update array schedule lock token of address
     */
    function overwriteScheduleLock(
        address _addressLock,
        uint256[] calldata _arrAmount,
        uint256[] calldata _arrUnlockTime
    ) external onlyManager {
        require(
            _arrAmount.length > 0 && _arrAmount.length == _arrUnlockTime.length,
            "The parameter passed was wrong"
        );
        require(
            mappingAddressToLock[_addressLock].totalLock > 0,
            "Address must in list lock"
        );
        _overwriteTimeLockByAddress(_addressLock, _arrAmount, _arrUnlockTime);
    }

    /**
     * @dev get lock time and amount lock by address at a time
     */
    function getScheduleLock(address _addressLock, uint256 _index)
        public
        view
        returns (uint256, uint256)
    {
        return (
            mappingAddressToLock[_addressLock].arrTimeLock[_index].amount,
            mappingAddressToLock[_addressLock].arrTimeLock[_index].unlockTime
        );
    }

    /**
     * @dev add list timeline lock and total amount lock by address
     */
    function addScheduleLockByAddress(
        address _addressLock,
        uint256[] calldata _arrAmount,
        uint256[] calldata _arrUnlockTime
    ) external onlyManager {
        require(
            _arrAmount.length > 0 && _arrAmount.length == _arrUnlockTime.length,
            "The parameter passed was wrong"
        );
        require(
            mappingAddressToLock[_addressLock].totalLock == 0,
            "Address must not in list lock"
        );
        _overwriteTimeLockByAddress(_addressLock, _arrAmount, _arrUnlockTime);
    }

    /**
     * @dev function overwrite schedule time lock and total by address lock
     */
    function _overwriteTimeLockByAddress(
        address _addressLock,
        uint256[] memory _arrAmount,
        uint256[] memory _arrUnlockTime
    ) internal returns (uint256) {
        uint256 totalLock = 0;
        delete mappingAddressToLock[_addressLock].arrTimeLock;
        _updateTotalLockByAddress(_addressLock, 0, 0);
        for (uint256 i = 0; i < _arrAmount.length; i++) {
            require(
                _arrUnlockTime[i] > 0,
                "The timeline must be greater than 0"
            );
            if (i != _arrAmount.length - 1) {
                require(
                    _arrUnlockTime[i + 1] > _arrUnlockTime[i],
                    "The next timeline must be greater than the previous"
                );
            }
            totalLock += _arrAmount[i];
            require(getAvailableBalance(_addressLock) >=  totalLock, "Insufficient amount to lock");
            _addScheduleLockByAddress(
                _addressLock,
                _arrUnlockTime[i],
                _arrAmount[i]
            );
        }
        _updateTotalLockByAddress(_addressLock, totalLock, 0);
        return totalLock;
    }

    /**
     * @dev unlock time locked token for address for manager
     */
    function _unLockTimeLockedTokenForAddress(address _address)
        external
        onlyManager
    {
        _unLockTimeLockedToken(_address);
    }

    /**
     * @dev transfer current manager to new manager
     */
    function transferManager(address newManager) public onlyOwner {
        _transferManager(newManager);
    }

    function _transferManager(address newManager) internal {
        require(newManager != address(0), "New Manager is the zero address");
        emit ManagerTransferred(_manager, newManager);
        _manager = newManager;
    }


    /** @dev Get current balance for locked token action of `account`
     */
    function getAvailableBalance(address account)
        public
        view
        virtual
        returns (uint256);
}

// File: contracts/token/ShopNextToken.sol


pragma solidity 0.8.7;




contract ShopNextToken is TimeLockedToken, VIPLockToken, SavingToken {
    bool transfersEnabled;
    event TransfersEnabled(bool newStatus);

    modifier transfersAllowed() {
        require(transfersEnabled, "Transfers not available");
        _;
    }

    constructor() TimeLockedToken("ShopNext Token", "NEXT", 1000000000) {}

    function transfer(address _receiver, uint256 _amount)
        public
        override
        returns (bool success)
    {
        _unLockTimeLockedToken(_msgSender());
        _vipUnlock(_msgSender());
        require(
            getAvailableBalance(_msgSender()) >= _amount,
            "Not enough unlocked token balance"
        );
        bool done = BEP20.transfer(_receiver, _amount);
        require(done, "Failed transfer");
        return true;
    }

    function transferFrom(
        address _from,
        address _receiver,
        uint256 _amount
    ) public override returns (bool) {
        require(_amount <= allowance(_from, msg.sender), "Invalid allowance amount");
        _unLockTimeLockedToken(_from);
        _vipUnlock(_from);
        require(
            getAvailableBalance(_from) >= _amount,
            "Not enough unlocked token balance of sender"
        );
        bool done = BEP20.transferFrom(_from, _receiver, _amount);
        require(done, "Failed transfer");
        return true;
    }

    /**
     * @dev Get current balance for all businesses of `account`
     */
    function getAvailableBalance(address _address)
        public
        view
        override(SavingToken, TimeLockedToken, VIPLockToken)
        returns (uint256 amount)
    {
        uint256 balance = balanceOf(_address);
        uint256 lockedAmount = getLockedAmount(_address);
        uint256 vipLockedAmount = currentVIPLockTokenOf(_address);
        uint256 savingLockedAmount = currentSavingTokenOf(_address);
        if (balance <= (lockedAmount + vipLockedAmount + savingLockedAmount))
            return 0;
        return balance - (lockedAmount + vipLockedAmount + savingLockedAmount);
    }

    /**
     * @dev Transfers tokens in batch
     * @param recipients an array of recipient addresses
     * @param values an array of specified amount of tokens to be transferred
     * @return success status of the batch transferring
     */
    function transfers(address[] calldata recipients, uint256[] calldata values)
        external
        transfersAllowed
        returns (bool)
    {
        require(
            recipients.length == values.length,
            "Input lengths do not match"
        );

        for (uint256 i = 0; i < recipients.length; i++) {
            bool done = transfer(recipients[i], values[i]);
            require (done, "Failed tranfer");
        }
        return true;
    }

    /**
     * @dev Enables the method ``transfers()`` if ``enable=true``,
     * and disables ``transfers()`` otherwise
     * @param enable the expected new availability of the method ``transfers()``
     */
    function enableTransfers(bool enable) public onlyOwner returns (bool) {
        transfersEnabled = enable;
        emit TransfersEnabled(enable);
        return true;
    }

    function getTokenDecimal() internal view override returns (uint8) {
        return decimals();
    }
}