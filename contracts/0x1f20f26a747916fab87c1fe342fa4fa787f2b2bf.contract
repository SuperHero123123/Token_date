{{
  "language": "Solidity",
  "sources": {
    "contracts/usd.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IUSD {\n    function owner() external view returns (address);\n\n    function minerTo() external view returns (address);\n\n    function stakeTo() external view returns (address);\n\n    function rewardTo() external view returns (address);\n\n    function inviter(address account_) external view returns (address);\n}\n\nlibrary TransferHelper {\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n}\n\ninterface IDepositUSD {\n    function withdrawToken(\n        address token_,\n        address to_,\n        uint256 amount_\n    ) external;\n\n    function stakeUsd(address account_, uint256 amount_) external;\n\n    function unstakeUsd(address account_, uint256 amount_) external;\n\n    function depositFee(uint256 amount_) external;\n\n    function takeFee(address account_, uint256 amount_) external;\n\n    function getFee() external view returns (uint256);\n\n    function stakedOf(address account_) external view returns (uint256);\n\n    function takeReward(\n        address token_,\n        string memory usefor,\n        address account_,\n        uint256 amount_\n    ) external;\n\n    function getReward(address token_, string memory usefor)\n        external\n        view\n        returns (uint256);\n}\n\n// 存储合约只支持钱,不支持主动存钱\n// 为了用户的安全性,在每次升级使用合约后,用户需重新授权\n// 在使用合约里面收取token并发送到存储合约-无手续费\ncontract DepositUSD {\n    address public usdAddress; // usd合约\n\n    uint256 public totalStaked; //总质押\n    mapping(address => uint256) public stakedOf; // 质押数量\n\n    uint256 public totalFees; //总手续费\n    uint256 public totalUsedFees; //已支付手续费\n    uint256 public bonusReward; //分红奖励\n\n    mapping(address => mapping(string => uint256)) public totalReward; //总奖励 reward[奖励token]\n    //奖励使用情况 reward[奖励token][usefor] =》 支付奖励\n    // usefor(string) invite(邀请奖励),,,,\n    mapping(address => mapping(string => uint256)) public useforReward; //已支付奖励\n\n    constructor(address usd_) {\n        usdAddress = usd_;\n    }\n\n    modifier onlyUseFor() {\n        require(\n            msg.sender == minerTo() ||\n                msg.sender == stakeTo() ||\n                msg.sender == owner() ||\n                msg.sender == rewardTo(),\n            \"caller can not be allowed\"\n        );\n        _;\n    }\n\n    function withdrawToken(\n        address token_,\n        address to_,\n        uint256 amount_\n    ) external onlyUseFor {\n        TransferHelper.safeTransfer(token_, to_, amount_);\n    }\n\n    function stakeUsd(address account_, uint256 amount_) external onlyUseFor {\n        totalStaked += amount_;\n        stakedOf[account_] += amount_;\n    }\n\n    function unstakeUsd(address account_, uint256 amount_) external onlyUseFor {\n        totalStaked -= amount_;\n        stakedOf[account_] -= amount_;\n        TransferHelper.safeTransfer(usdAddress, account_, amount_);\n    }\n\n    // 获取可使用的奖励\n    function getReward(address token_, string memory usefor)\n        public\n        view\n        returns (uint256)\n    {\n        return totalReward[token_][usefor] - useforReward[token_][usefor];\n    }\n\n    // 请将存储合约加入奖励token白名单使用,以免除手续费溢出\n    function depositReward(\n        address token_,\n        string memory usefor,\n        uint256 amount_\n    ) public {\n        totalReward[token_][usefor] += amount_;\n        TransferHelper.safeTransferFrom(\n            token_,\n            msg.sender,\n            address(this),\n            amount_\n        );\n    }\n\n    // 使用奖励\n    function takeReward(\n        address token_,\n        string memory usefor,\n        address account_,\n        uint256 amount_\n    ) external onlyUseFor {\n        require(getReward(token_, usefor) >= amount_, \"not enough fee\");\n        useforReward[token_][usefor] += amount_;\n        TransferHelper.safeTransfer(token_, account_, amount_);\n    }\n\n    function getFee() public view returns (uint256) {\n        return totalFees - totalUsedFees;\n    }\n\n    function depositFee(uint256 amount_) external {\n        if (msg.sender != usdAddress) {\n            TransferHelper.safeTransferFrom(\n                usdAddress,\n                msg.sender,\n                address(this),\n                amount_\n            );\n        }\n        totalFees += amount_;\n    }\n\n    function bonusFee(uint256 amount_) external onlyUseFor {\n        require(getFee() >= amount_, \"not enough fee\");\n        totalUsedFees += amount_;\n        bonusReward += amount_;\n    }\n\n    function takeFee(address account_, uint256 amount_) external onlyUseFor {\n        if (amount_ > bonusReward) {\n            amount_ = bonusReward;\n        }\n        bonusReward -= amount_;\n        TransferHelper.safeTransfer(usdAddress, account_, amount_);\n    }\n\n    function owner() public view returns (address) {\n        return IUSD(usdAddress).owner();\n    }\n\n    function minerTo() public view returns (address) {\n        return IUSD(usdAddress).minerTo();\n    }\n\n    function stakeTo() public view returns (address) {\n        return IUSD(usdAddress).stakeTo();\n    }\n\n    function rewardTo() public view returns (address) {\n        return IUSD(usdAddress).rewardTo();\n    }\n}\n\ncontract UpgradeMaster {\n    uint256 public effectiveTime = 300; // 升级合约的有效时间\n\n    address public owner; // 拥有者地址\n    Upgrade public _minerTo; // 矿工合约地址\n    Upgrade public _stakeTo; // 质押合约地址\n    Upgrade public _rewardTo; // 奖励合约地址\n\n    struct Upgrade {\n        address prev; // 原合约地址\n        address to; // 升级合约地址\n        uint256 effectiveTime; // 生效时间\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"caller is not the owner\");\n        _;\n    }\n\n    modifier onlyMiner() {\n        require(minerTo() == msg.sender, \"caller is not the miner\");\n        _;\n    }\n\n    function minerTo() public view returns (address) {\n        return _getUpgradeTo(_minerTo);\n    }\n\n    function stakeTo() public view returns (address) {\n        return _getUpgradeTo(_stakeTo);\n    }\n\n    function rewardTo() public view returns (address) {\n        return _getUpgradeTo(_rewardTo);\n    }\n\n    function setEffectiveTime(uint256 newEffectiveTime) external onlyOwner {\n        require(\n            newEffectiveTime > effectiveTime,\n            \"new effective time is too short\"\n        );\n        effectiveTime = newEffectiveTime;\n    }\n\n    function setOwner(address to) external onlyOwner {\n        owner = to;\n    }\n\n    function setMinerTo(address to) external onlyOwner {\n        _upgradeTo(_minerTo, to);\n    }\n\n    function setStakeTo(address to) external onlyOwner {\n        _upgradeTo(_stakeTo, to);\n    }\n\n    function setRewardTo(address to) external onlyOwner {\n        _upgradeTo(_rewardTo, to);\n    }\n\n    function _getUpgradeTo(Upgrade memory upgrade_)\n        internal\n        view\n        returns (address)\n    {\n        if (block.timestamp >= upgrade_.effectiveTime) {\n            return upgrade_.to;\n        } else {\n            return upgrade_.prev;\n        }\n    }\n\n    function _upgradeTo(Upgrade storage upgrade_, address to) internal {\n        // 第一次设置直接生效\n        if (upgrade_.effectiveTime == 0) {\n            upgrade_.to = to;\n        }\n\n        if (block.timestamp >= upgrade_.effectiveTime) {\n            upgrade_.prev = upgrade_.to;\n        }\n\n        upgrade_.to = to;\n        upgrade_.effectiveTime = block.timestamp + effectiveTime;\n    }\n}\n\ncontract TokenUSD is UpgradeMaster {\n    string public name = \"TokenUSD\";\n    string public symbol = \"TokenUSD\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 0;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    mapping(address => bool) public whiteFrom; // 转出白名单\n    mapping(address => bool) public whiteTo; // 转入白名单\n    mapping(address => bool) public blackFrom; // 转出黑名单\n\n    mapping(address => address) public inviter; // 邀请人\n    mapping(address => uint256) public inviteCount; // 邀请人数量\n\n    uint256 public feeRate = 30; //转账手续费 feeRate / 10000 30\n    uint256 public feeMax = 1e18; // 最高手续费 默认1U 1e18\n\n    address public immutable depositAddress; // 存款合约地址\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed holder,\n        address indexed spender,\n        uint256 value\n    );\n    event BindInviter(address indexed _user, address indexed _inviter);\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        owner = msg.sender;\n\n        depositAddress = address(new DepositUSD(address(this)));\n\n        // 初始化白名单\n        whiteFrom[address(this)] = true;\n        whiteTo[address(this)] = true;\n\n        whiteFrom[depositAddress] = true;\n        whiteTo[depositAddress] = true;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        virtual\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount)\n        external\n        virtual\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual returns (bool) {\n        uint256 currentAllowance = allowance[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n\n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = allowance[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(!blackFrom[sender], \"ERC20: transfer from black list\");\n        // require(!blackFrom[to], \"ERC20: transfer to black list\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = balanceOf[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            balanceOf[sender] = senderBalance - amount;\n        }\n        balanceOf[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        totalSupply += amount;\n        balanceOf[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        require(balanceOf[account] >= amount, \"ERC20: burn more than balance\");\n        require(totalSupply >= amount, \"ERC20: burn more than total supply\");\n        totalSupply -= amount;\n        balanceOf[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[holder][spender] = amount;\n        emit Approval(holder, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (whiteFrom[from] || whiteTo[to]) {\n            return;\n        }\n\n        if (from == address(0) || to == address(0)) {\n            return;\n        }\n\n        uint256 fee = (amount * feeRate) / 10000;\n        if (fee > feeMax) {\n            fee = feeMax;\n        }\n\n        //扣减手续费\n        balanceOf[to] -= fee;\n        //存入存款合约\n        IDepositUSD(depositAddress).depositFee(fee);\n        balanceOf[depositAddress] += fee;\n        emit Transfer(to, depositAddress, fee);\n    }\n\n    function mint(address recipient, uint256 amount)\n        external\n        virtual\n        onlyMiner\n        returns (bool)\n    {\n        _mint(recipient, amount);\n        return true;\n    }\n\n    function burn(address account, uint256 amount)\n        external\n        virtual\n        onlyMiner\n        returns (bool)\n    {\n        _burn(account, amount);\n        return true;\n    }\n\n    // 绑定邀请人\n    function setInviter(address inviter_) external virtual returns (bool) {\n        require(inviter[msg.sender] == address(0), \"already bind inviter\");\n        require(msg.sender != inviter_, \"can't bind self\");\n        // 上级必须已经绑定过邀请人或者绑定管理员帐号\n        require(\n            inviter_ == owner || inviter[inviter_] != address(0),\n            \"inviter must be binded\"\n        );\n\n        inviter[msg.sender] = inviter_;\n        inviteCount[inviter_] += 1;\n        emit BindInviter(msg.sender, inviter_);\n        return true;\n    }\n\n    //设置黑名单\n    function setBlackFrom(address addr, bool value) external onlyOwner {\n        blackFrom[addr] = value;\n    }\n\n    //设置白名单\n    function setWhite(\n        address addr,\n        bool from,\n        bool to\n    ) external onlyOwner {\n        whiteFrom[addr] = from;\n        whiteTo[addr] = to;\n    }\n\n    //设置手续费\n    function setFeeMax(uint256 newFeeMax) external onlyOwner {\n        feeMax = newFeeMax;\n    }\n\n    //设置手续费率\n    function setFeeRate(uint256 newFeeRate) external onlyOwner {\n        require(newFeeRate <= 10000, \"fee rate error\");\n        feeRate = newFeeRate;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}