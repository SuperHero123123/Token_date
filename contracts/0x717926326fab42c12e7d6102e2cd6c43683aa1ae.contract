{{
  "language": "Solidity",
  "sources": {
    "AdoToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n// Web: https://www.ado.network\n// Twitter: https://twitter.com/NetworkAdo\n// Discord: https://discord.gg/n9FyS5Tr\n// Telegram: https://t.me/ADONetworkEnglish\n// Reddit: https://www.reddit.com/r/ADO_Network/\n\n// ADO works simultaneously with two liquidity pools, ADO-BNB and ADO-BUSD.\n// ADO can switch between pools anytime, moving 99% of the funds from\n// main pool to secondary pool and generate revenue for holders by earning in price compared to the price of BNB.\n// ADO.Network Team is not responsible for any losses incurred by swaping in the secondary pool.\n// If you use PancakeSwap, make sure you are dealing with the Main Pool.\n// We'd recommend using the swap mode on www.ado.network as it is set to always work with the Main Pool.\nimport \"./libraries/SafeMath.sol\";\nimport \"./DividendTracker.sol\";\nimport \"./AdoVault.sol\";\nimport \"./LPManager.sol\";\nimport \"./abstracts/Ownable.sol\";\nimport \"./interfaces/IBEP20.sol\";\nimport \"./interfaces/IPancakeSwapV2Pair.sol\";\nimport \"./interfaces/IPancakeSwapV2Factory.sol\";\nimport \"./interfaces/IPancakeSwapV2Router02.sol\";\n\ncontract AdoToken is IBEP20, Ownable {\n\tusing SafeMath for uint256;\n\n\taddress private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\taddress public immutable deployer;\n\taddress public mainLPToken;\n\tIPancakeSwapV2Router02 public pancakeSwapV2Router;\n\tIPancakeSwapV2Pair public pancakeSwapWETHV2Pair;\n\tIPancakeSwapV2Pair public pancakeSwapBUSDV2Pair;\n\tDividendTracker public dividendContract;\n\tLPManager public lpManager;\n\tIBEP20 public busdContract;\n\t\n\tstring private _name = \"ADO.Network\";\n\tstring private _symbol = \"ADO\";\n\tuint8 private _decimals = 18;\n\tbool public swapEnabled = false;\n\tbool private _swapping = false;\n\tbool private _dividendContractSet = false;\n\tbool private _busdContractSet = false;\n\tbool private _lpManagerSet = false;\n\tuint256 private _totalSupply = 1000000000 * (10 ** _decimals);\n\tuint256 private _tokensToLiqudate = _totalSupply.div(10000);\n\tuint256 private _lpWeight;\n\tuint256 private _holdersLotteryFund;\n\tuint256 private _referrersLotteryFund;\n\tuint256 private _buyBackBalance;\n\tuint256 private _cursor;\n\tuint256 private _dividendFee = 2;\n\tuint256 private _buyBackFee = 6;\n\tuint256 private _lotteryFee = 2;\n\tuint256 private _totalFee = 10;\n\tuint256 private _totalIterations;\n\tuint256 public partners;\n\tmapping(address => uint256) private _balances;\n\tmapping(address => mapping(address => uint256)) private _allowances;\n\tmapping (address => bool) private _isExcludedFromFees;\n\tmapping (address => bool) private _partners;\n\n\tevent ExcludedAddress(address indexed account, bool fromFee, bool fromDividends, bool fromLottery);\n\tevent NewPartner(address indexed account);\n\tevent BuyBackUpdate(address indexed token, uint256 eth, uint256 busd);\n\tevent LPWeight(uint256 lp, uint256 bb);\n\tevent FeeDistribution(uint256 buyBack, uint256 dividend, uint256 lottery);\n\tevent TokenBalanceToLiqudate(uint256 indexed newValue, uint256 indexed oldValue);\n\tevent ProcessedDividendTracker(uint256 iterations, uint256 claims, uint256 indexed lastProcessedIndex, bool indexed automatic, uint256 gas, address indexed processor);\n\tevent MainLPSwitch(address indexed newToken);\n\n\tmodifier onlyDeployer() {\n\t\trequire(_msgSender() == deployer, \"Token: Only the token deployer can call this function\");\n\t\t_;\n\t}\n\n\tconstructor() {\n\t\tdeployer = owner();\n\t\t_isExcludedFromFees[owner()] = true;\n\t\t_isExcludedFromFees[address(this)] = true;\n\t\t_isExcludedFromFees[BURN_ADDRESS] = true;\n\t\t_balances[owner()] = _totalSupply;\n\t\temit Transfer(address(0), owner(), _totalSupply);\n\t}\n\n\treceive() external payable {}\n\n\tfunction name() external view override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\tfunction symbol() external view override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\tfunction decimals() external view override returns (uint8) {\n\t\treturn _decimals;\n\t}\n\n\tfunction getOwner() external view override returns (address) {\n\t\treturn owner();\n\t}\n\n\tfunction totalFee() external view returns (uint256) {\n\t\treturn _totalFee;\n\t}\n\n\tfunction fees() external view returns (uint256 dividendFee, uint256 buyBackFee, uint256 lotteryFee, bool isActive) {\n\t\tdividendFee = _dividendFee;\n\t\tbuyBackFee = _buyBackFee;\n\t\tlotteryFee = _lotteryFee;\n\t\tisActive = _totalFee > 0;\n\t}\n\n\tfunction totalSupply() external view override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\tfunction balanceOf(address account) external view override returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\tfunction isExcludedFromFees(address account) external view returns(bool) {\n\t\treturn _isExcludedFromFees[account];\n\t}\n\n\tfunction tokensToLiqudate() external view returns(uint256) {\n\t\treturn _tokensToLiqudate;\n\t}\n\n\tfunction totalIterations() external view returns(uint256) {\n\t\treturn _totalIterations;\n\t}\n\n\tfunction cursor() external view returns(uint256) {\n\t\treturn _cursor;\n\t}\n\n\tfunction lpvsbb() external view returns(uint256 lp, uint256 bb) {\n\t\tuint256 weight = 10;\n\t\tlp = _lpWeight;\n\t\tbb = weight.sub(_lpWeight);\n\t}\n\n\tfunction funds() external view returns(uint256 hlf, uint256 rlf, uint256 bbbnb, uint256 bbbusd) {\n\t\thlf = _holdersLotteryFund;\n\t\trlf = _referrersLotteryFund;\n\t\tbbbnb = _buyBackBalance;\n\t\tbbbusd = busdContract.balanceOf(address(this));\n\t}\n\n\tfunction transfer(address recipient, uint256 amount) external override returns (bool) {\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\tfunction allowance(address owner, address spender) external view override returns (uint256) {\n\t\treturn _allowances[owner][spender];\n\t}\n\n\tfunction approve(address spender, uint256 amount) external override returns (bool) {\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"Token: transfer amount exceeds allowance\"));\n\t\treturn true;\n\t}\n\n\tfunction updateLPWeight(uint256 lpWeight) external onlyDeployer returns (bool) {\n\t\trequire(lpWeight <= 10, \"Token: LPWeight must be between 0 and 10\");\n\t\t_lpWeight = lpWeight;\n\t\temit LPWeight(_lpWeight, 10 - _lpWeight);\n\t\treturn true;\n\t}\n\n\tfunction updateFeeDistribution(uint256 newBuyBackFee) external onlyDeployer returns (bool) {\n\t\trequire(newBuyBackFee != _buyBackFee, \"Token: The BuyBack fee is already set to the requested value\");\n\t\trequire(newBuyBackFee == 2 || newBuyBackFee == 4 || newBuyBackFee == 6, \"Token: The BuyBack fee can only be 2 4 or 6\");\n\t\t_buyBackFee = newBuyBackFee;\n\t\t_dividendFee = _totalFee.sub(_buyBackFee).sub(_lotteryFee);\n\t\temit FeeDistribution(_buyBackFee, _dividendFee, _lotteryFee);\n\t\treturn true;\n\t}\n\n\tfunction updateTokensToLiqudate(uint256 newValue) external onlyDeployer returns (bool) {\n\t\trequire(newValue >= 100000000000000000000 && newValue <= 1000000000000000000000000, \"Token: numTokensToLiqudate must be between 100 and 1.000.000 ADO\");\n\t\temit TokenBalanceToLiqudate(newValue, _tokensToLiqudate);\n\t\t_tokensToLiqudate = newValue;\n\t\treturn true;\n\t}\n\n\tfunction buyBack(uint256 amount, address recipient) external onlyDeployer {\n\t\trequire(recipient == BURN_ADDRESS || recipient == address(dividendContract), \"Token: Invalid recipient.\");\n\t\tif (mainLPToken == pancakeSwapV2Router.WETH()) {\n\t\t\trequire(amount <= _buyBackBalance, \"Token: Insufficient funds.\");\n\t\t\tswapETHForTokens(recipient, 0, amount);\n\t\t\t_buyBackBalance = address(this).balance\n\t\t\t\t.sub(_holdersLotteryFund)\n\t\t\t\t.sub(_referrersLotteryFund);\n\t\t} else {\n\t\t\trequire(amount <= busdContract.balanceOf(address(this)), \"Token: Insufficient funds.\");\n\t\t\taddress[] memory path = new address[](2);\n\t\t\tpath[0] = address(busdContract);\n\t\t\tpath[1] = address(this);\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), amount);\n\t\t\tpancakeSwapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\t\t\tamount,\n\t\t\t\t0,\n\t\t\t\tpath,\n\t\t\t\trecipient,\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction processDividendTracker() external onlyDeployer {\n\t\trequire(_dividendContractSet, \"Token: Dividend Contract Token is not set\");\n\t\tuint256 contractTokenBalance = _balances[address(this)];\n\t\tbool canSwap = contractTokenBalance > _tokensToLiqudate;\n\t\tif (canSwap) {\n\t\t\t_swapping = true;\n\t\t\tswapAndSendDividends(_tokensToLiqudate);\n\t\t\t_swapping = false;\n\t\t}\n\t\tuint256 _iterations = 0;\n\t\ttry dividendContract.process() returns (uint256 iterations, uint256 claims, uint256 lpIndex) {\n\t\t\temit ProcessedDividendTracker(iterations, claims, lpIndex, true, dividendContract.gasForProcessing(), tx.origin);\n\t\t\t_iterations = iterations;\n\t\t} catch {}\n\t\t_totalIterations = _totalIterations.add(_iterations);\n\t}\n\n\tfunction addPartner(address account) external onlyDeployer returns (uint256) {\n\t\trequire(_partners[account] == false, \"Token: Account is a partner\");\n\t\t_partners[account] = true;\n\t\tpartners++;\n\t\tdividendContract.excludeFromLottery(account);\n\t\temit NewPartner(account);\n\t\treturn partners;\n\t}\n\n\tfunction excludeAddress(address account, bool fromFee, bool fromDividends, bool fromLottery) external onlyDeployer returns (bool) {\n\t\tif (fromFee) {\n\t\t\trequire(_isExcludedFromFees[account] == false, \"Token: Account is already excluded\");\n\t\t\t_isExcludedFromFees[account] = true;\n\t\t}\n\t\tif (fromDividends) {\n\t\t\tdividendContract.excludeFromDividends(account);\n\t\t}\n\t\tif (fromLottery) {\n\t\t\tdividendContract.excludeFromLottery(account);\n\t\t}\n\t\temit ExcludedAddress(account, fromFee, fromDividends, fromLottery);\n\t\treturn true;\n\t}\n\n\tfunction removeTax() external onlyDeployer returns (uint256) {\n\t\trequire(dividendContract.maxMilestone() == 0, \"Token: milestone in progress\");\n\t\t_totalFee = 0;\n\t\tuint256 burnedAmount = _balances[address(this)];\n\t\t_transfer(address(this), BURN_ADDRESS, burnedAmount);\n\t\t_buyBackBalance = address(this).balance;\n\t\t_holdersLotteryFund = 0;\n\t\t_referrersLotteryFund = 0;\n\t\tuint256 dBurnedAmount = dividendContract.burnTheHouseDown();\n\t\treturn burnedAmount.add(dBurnedAmount);\n\t}\n\n\tfunction _approve(address owner, address spender, uint256 amount) private {\n\t\trequire(owner != address(0), \"Token: approve from the zero address\");\n\t\trequire(spender != address(0), \"Token: approve to the zero address\");\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction swapBUSDforETH(uint256 amount, address to) private returns (uint256) {\n\t\tuint256 initialBalance = address(this).balance;\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = address(busdContract);\n\t\tpath[1] = pancakeSwapV2Router.WETH();\n\t\tbusdContract.approve(address(pancakeSwapV2Router), amount);\n\t\tpancakeSwapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\t\tamount,\n\t\t\t0,\n\t\t\tpath,\n\t\t\tto,\n\t\t\tblock.timestamp\n\t\t);\n\t\treturn address(this).balance.sub(initialBalance);\n\t}\n\n\tfunction swapETHforBUSD(uint256 amount, address to) private returns (uint256) {\n\t\tuint256 initialBalance = busdContract.balanceOf(address(this));\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = pancakeSwapV2Router.WETH();\n\t\tpath[1] = address(busdContract);\n\t\tpancakeSwapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(0, path, to, block.timestamp);\n\t\treturn busdContract.balanceOf(address(this)).sub(initialBalance);\n\t}\n\n\tfunction swapETHForTokens(address recipient, uint256 minTokenAmount, uint256 amount) private {\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = pancakeSwapV2Router.WETH();\n\t\tpath[1] = address(this);\n\t\tpancakeSwapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\n\t\t\tminTokenAmount,\n\t\t\tpath,\n\t\t\trecipient,\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\tfunction swapTokensForEth(uint256 tokenAmount) public returns (uint256) {\n\t\tuint256 pathlength = mainLPToken == pancakeSwapV2Router.WETH() ? 2 : 3;\n\t\taddress[] memory path = new address[](pathlength);\n\t\tpath[0] = address(this);\n\t\tpath[1] = mainLPToken;\n\t\tif (mainLPToken != pancakeSwapV2Router.WETH()) {\n\t\t\tpath[2] = pancakeSwapV2Router.WETH();\n\t\t}\n\t\tuint256 initialBalance = address(this).balance;\n\t\t_approve(address(this), address(pancakeSwapV2Router), tokenAmount);\n\t\tpancakeSwapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\t\ttokenAmount,\n\t\t\t0,\n\t\t\tpath,\n\t\t\taddress(this),\n\t\t\tblock.timestamp\n\t\t);\n\t\tuint256 eth = address(this).balance.sub(initialBalance);\n\t\treturn eth;\n\t}\n\n\tfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n\t\t_approve(address(this), address(pancakeSwapV2Router), tokenAmount);\n\t\tpancakeSwapV2Router.addLiquidityETH{value: ethAmount}(\n\t\t\taddress(this),\n\t\t\ttokenAmount,\n\t\t\t0,\n\t\t\t0,\n\t\t\taddress(lpManager),\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\tfunction swapAndSendDividends(uint256 amount) private {\n\t\t_cursor++;\n\t\tbool addLP = (mainLPToken == pancakeSwapV2Router.WETH()) && (_cursor.mod(10) < _lpWeight);\n\t\tuint256 swapTokensAmount = amount;\n\t\tif (addLP) {\n\t\t\tuint256 lpf = _buyBackFee.div(2);\n\t\t\tlpf = lpf.add(_lotteryFee).add(_dividendFee);\n\t\t\tswapTokensAmount = amount.div(_totalFee).mul(lpf);\n\t\t}\n\t\tuint256 eth = swapTokensForEth(swapTokensAmount);\n\t\tuint256 lotteriesEth = eth.div(_totalFee).mul(_lotteryFee);\n\t\t_holdersLotteryFund = _holdersLotteryFund.add(lotteriesEth.div(2));\n\t\t_referrersLotteryFund = _referrersLotteryFund.add(lotteriesEth.div(2));\n\t\tuint256 dividendEth = eth.div(_totalFee).mul(_dividendFee);\n\t\t(bool dividendContractTransfer,) = payable(address(dividendContract)).call{value: dividendEth, gas: 3000}('');\n\t\tif (dividendContractTransfer) {\n\t\t\tdividendContract.updateDividendsDistributed(dividendEth);\n\t\t}\n\t\tif (addLP) {\n\t\t\tuint256 lpeth = eth.sub(lotteriesEth).sub(dividendEth);\n\t\t\taddLiquidity(amount.sub(swapTokensAmount), lpeth);\n\t\t}\n\t\t_buyBackBalance = address(this).balance.sub(_holdersLotteryFund).sub(_referrersLotteryFund);\n\t}\n\n\tfunction _transfer(address from, address to, uint256 amount) private {\n\t\trequire(from != address(0), \"Token: Transfer from the zero address\");\n\t\trequire(to != address(0), \"Token: Transfer to the zero address\");\n\t\trequire(amount > 0, \"Token: Transfer amount must be greater than zero\");\n\t\trequire(swapEnabled || from == deployer, \"Token: Public transfer has not yet been activated\");\n\t\trequire(_dividendContractSet, \"Token: Dividend Contract Token is not set\");\n\t\t\n\t\tbool takeFee = true;\n\t\tbool process = true;\n\t\tif (\n\t\t\t_isExcludedFromFees[from] ||\n\t\t\t_isExcludedFromFees[to] ||\n\t\t\t(_partners[from]) ||\n\t\t\t(_partners[to])\n\t\t) {\n\t\t\ttakeFee = false;\n\t\t\tprocess = false;\n\t\t\tif (_partners[from]) {\n\t\t\t\tif (to == address(pancakeSwapWETHV2Pair) || to == address(pancakeSwapBUSDV2Pair)) takeFee = true;\n\t\t\t}\n\t\t\tif (_partners[to]) {\n\t\t\t\tif (from == address(pancakeSwapWETHV2Pair) || from == address(pancakeSwapBUSDV2Pair)) takeFee = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!_swapping && _totalFee != 0 && takeFee) {\n\t\t\tuint256 contractTokenBalance = _balances[address(this)];\n\t\t\tbool canSwap = contractTokenBalance > _tokensToLiqudate;\n\t\t\tif (canSwap) {\n\t\t\t\tif (\n\t\t\t\t\t(mainLPToken == pancakeSwapV2Router.WETH() && from != address(pancakeSwapWETHV2Pair)) ||\n\t\t\t\t\t(mainLPToken == address(busdContract) && from != address(pancakeSwapBUSDV2Pair)))\n\t\t\t\t{\n\t\t\t\t\t_swapping = true;\n\t\t\t\t\tswapAndSendDividends(_tokensToLiqudate);\n\t\t\t\t\t_swapping = false;\n\t\t\t\t\tprocess = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tuint256 txFee = amount.div(100).mul(_totalFee);\n\t\t\tamount = amount.sub(txFee);\n\t\t\t_balances[from] = _balances[from].sub(txFee, \"Token: Transfer amount exceeds balance\");\n\t\t\t_balances[address(this)] = _balances[address(this)].add(txFee);\n\t\t\temit Transfer(from, address(this), txFee);\n\t\t}\n\n\t\t_balances[from] = _balances[from].sub(amount, \"Token: Transfer amount exceeds balance\");\n\t\t_balances[to] = _balances[to].add(amount);\n\t\temit Transfer(from, to, amount);\n\n\t\tdividendContract.setBalance(payable(from), _balances[from], false);\n\t\tdividendContract.setBalance(payable(to), _balances[to], true);\n\n\t\tif (!_swapping && process) {\n\t\t\tif (\n\t\t\t\tfrom == address(pancakeSwapWETHV2Pair) ||\n\t\t\t\tto == address(pancakeSwapWETHV2Pair) ||\n\t\t\t\tfrom == address(pancakeSwapBUSDV2Pair) ||\n\t\t\t\tto == address(pancakeSwapBUSDV2Pair)\n\t\t\t) {\n\t\t\t\tuint256 _iterations = 0;\n\t\t\t\ttry dividendContract.process() returns (uint256 iterations, uint256 claims, uint256 lpIndex) {\n\t\t\t\t\temit ProcessedDividendTracker(iterations, claims, lpIndex, true, dividendContract.gasForProcessing(), tx.origin);\n\t\t\t\t\t_iterations = iterations;\n\t\t\t\t} catch {}\n\t\t\t\t_totalIterations = _totalIterations.add(_iterations);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setDividendTrackerContract(address _dividendTracker, uint256 amount) external onlyOwner {\n\t\tdividendContract = DividendTracker(payable(_dividendTracker));\n\t\t_dividendContractSet = true;\n\t\t_isExcludedFromFees[_dividendTracker] = true;\n\t\t_transfer(_msgSender(), _dividendTracker, amount);\n\t}\n\n\tfunction setLPManeger(address _lpManager) external onlyOwner {\n\t\trequire(!_lpManagerSet, \"Token: LP Maneger is already set\");\n\t\trequire(address(pancakeSwapV2Router) != address(0), \"Token: PancakeSwapV2 Router is not set\");\n\t\trequire(address(pancakeSwapWETHV2Pair) != address(0), \"Token: PancakeSwapV2 WETH Pair is not set\");\n\t\trequire(address(pancakeSwapBUSDV2Pair) != address(0), \"Token: PancakeSwapV2 BUSD Pair is not set\");\n\t\tlpManager = LPManager(payable(_lpManager));\n\t\t_lpManagerSet = true;\n\t\t_isExcludedFromFees[_lpManager] = true;\n\t\tdividendContract.excludeFromDividends(_lpManager);\n\t}\n\n\tfunction setBUSDContract(address _busd) external onlyOwner {\n\t\trequire(!_busdContractSet, \"Token: BUSD Token is already set\");\n\t\tbusdContract = IBEP20(_busd);\n\t\t_busdContractSet = true;\n\t}\n\n\tfunction createPancakeSwapPair(address PancakeSwapRouter) external onlyOwner {\n\t\trequire(_dividendContractSet, \"Token: Dividend Contract contract is not set\");\n\t\trequire(_busdContractSet, \"Token: BUSD Token Contract contract is not set\");\n\t\tpancakeSwapV2Router = IPancakeSwapV2Router02(PancakeSwapRouter);\n\t\tpancakeSwapWETHV2Pair = IPancakeSwapV2Pair(IPancakeSwapV2Factory(pancakeSwapV2Router\n\t\t\t.factory())\n\t\t\t.createPair(address(this), pancakeSwapV2Router.WETH()));\n\t\tmainLPToken = pancakeSwapV2Router.WETH();\n\t\tpancakeSwapBUSDV2Pair = IPancakeSwapV2Pair(IPancakeSwapV2Factory(pancakeSwapV2Router\n\t\t\t.factory())\n\t\t\t.createPair(address(this), address(busdContract)));\n\t\tdividendContract.excludeFromDividends(address(pancakeSwapV2Router));\n\t\tdividendContract.excludeFromDividends(address(pancakeSwapWETHV2Pair));\n\t\tdividendContract.excludeFromDividends(address(pancakeSwapBUSDV2Pair));\n\t}\n\n\tfunction enableSwap() external onlyDeployer returns (bool) {\n\t\trequire(!swapEnabled, \"Token: PublicSwap is already enabeled\");\n\t\trequire(address(pancakeSwapV2Router) != address(0), \"Token: PancakeSwapV2 Router is not set\");\n\t\tswapEnabled = true;\n\t\treturn swapEnabled;\n\t}\n\n\tfunction swapETHForExactTokens(uint256 amountOut, address referrer) external payable returns (uint256) {\n\t\taddress[] memory path = new address[](2);\n\t\tpath[1] = address(this);\n\t\tif (mainLPToken == pancakeSwapV2Router.WETH()) {\n\t\t\tpath[0] = pancakeSwapV2Router.WETH();\n\t\t\tpancakeSwapV2Router.swapETHForExactTokens{value: msg.value}(\n\t\t\t\tamountOut,\n\t\t\t\tpath,\n\t\t\t\t_msgSender(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 ethBack = address(this).balance\n\t\t\t\t.sub(_holdersLotteryFund)\n\t\t\t\t.sub(_referrersLotteryFund)\n\t\t\t\t.sub(_buyBackBalance);\n\t\t\t(bool refund, ) = _msgSender().call{value: ethBack, gas: 3000}(\"\");\n\t\t\trequire(refund, \"Token: Refund Failed\");\n\t\t} else {\n\t\t\tuint256 initialBUSDBalance = busdContract.balanceOf(address(this));\n\t\t\tpath[0] = address(busdContract);\n\t\t\tuint256 busdAmount = swapETHforBUSD(msg.value, address(this));\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), busdAmount);\n\t\t\tpancakeSwapV2Router.swapTokensForExactTokens(\n\t\t\t\tamountOut,\n\t\t\t\tbusdAmount,\n\t\t\t\tpath,\n\t\t\t\t_msgSender(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 busdBack = busdContract.balanceOf(address(this))\n\t\t\t\t.sub(initialBUSDBalance);\n\t\t\tswapBUSDforETH(busdBack, _msgSender());\n\t\t}\n\t\tuint256 txFee = amountOut.div(100).mul(_totalFee);\n\t\tuint256 amount = amountOut.sub(txFee);\n\t\tif (referrer != address(0) && referrer != _msgSender() && _totalFee > 0) {\n\t\t\tdividendContract.payCommission(referrer, amount);\n\t\t}\n\t\treturn amount;\n\t}\n\n\tfunction swapBUSDForExactTokens(uint256 busdAmount, uint256 amountOut, address referrer) external returns (uint256) {\n\t\tuint256 initialBUSDBalance = busdContract.balanceOf(address(this));\n\t\tbusdContract.transferFrom(_msgSender(), address(this), busdAmount);\n\t\taddress[] memory path = new address[](2);\n\t\tpath[1] = address(this);\n\t\tif (mainLPToken == pancakeSwapV2Router.WETH()) {\n\t\t\tuint256 eth = swapBUSDforETH(busdAmount, address(this));\n\t\t\tpath[0] = pancakeSwapV2Router.WETH();\n\t\t\tpancakeSwapV2Router.swapETHForExactTokens{value: eth}(\n\t\t\t\tamountOut,\n\t\t\t\tpath,\n\t\t\t\t_msgSender(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 ethBack = address(this).balance\n\t\t\t\t.sub(_buyBackBalance)\n\t\t\t\t.sub(_holdersLotteryFund)\n\t\t\t\t.sub(_referrersLotteryFund);\n\t\t\tswapETHforBUSD(ethBack, _msgSender());\n\t\t} else {\n\t\t\tpath[0] = address(busdContract);\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), busdAmount);\n\t\t\tpancakeSwapV2Router.swapTokensForExactTokens(\n\t\t\t\tamountOut,\n\t\t\t\tbusdAmount,\n\t\t\t\tpath,\n\t\t\t\t_msgSender(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 busdBack = busdContract.balanceOf(address(this))\n\t\t\t\t.sub(initialBUSDBalance);\n\t\t\tbusdContract.transfer(_msgSender(), busdBack);\n\t\t}\n\t\tuint256 txFee = amountOut.div(100).mul(_totalFee);\n\t\tuint256 amount = amountOut.sub(txFee);\n\t\tif (referrer != address(0) && referrer != _msgSender() && _totalFee > 0) {\n\t\t\tdividendContract.payCommission(referrer, amount);\n\t\t}\n\t\treturn amount;\n\t}\n\n\tfunction swapExactETHForTokens(uint256 amountOutMin, address referrer) external payable returns (uint256) {\n\t\tuint256 initialTokenBalance = _balances[_msgSender()];\n\t\tif (mainLPToken == pancakeSwapV2Router.WETH()) {\n\t\t\tswapETHForTokens(_msgSender(), amountOutMin, msg.value);\n\t\t} else {\n\t\t\tuint256 busdAmount = swapETHforBUSD(msg.value, address(this));\n\t\t\taddress[] memory path = new address[](2);\n\t\t\tpath[0] = address(busdContract);\n\t\t\tpath[1] = address(this);\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), busdAmount);\n\t\t\tpancakeSwapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\t\t\tbusdAmount,\n\t\t\t\tamountOutMin,\n\t\t\t\tpath,\n\t\t\t\t_msgSender(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t}\n\t\tuint256 amount = _balances[_msgSender()].sub(initialTokenBalance);\n\t\tif (referrer != address(0) && referrer != _msgSender() && _totalFee > 0) {\n\t\t\tdividendContract.payCommission(referrer, amount);\n\t\t}\n\t\treturn amount;\n\t}\n\n\tfunction swapExactBUSDForTokens(uint256 busdAmount, uint256 amountOutMin, address referrer) external returns (uint256) {\n\t\tbusdContract.transferFrom(_msgSender(), address(this), busdAmount);\n\t\tuint256 initialTokenBalance = _balances[_msgSender()];\n\t\tif (mainLPToken == pancakeSwapV2Router.WETH()) {\n\t\t\tuint256 eth = swapBUSDforETH(busdAmount, address(this));\n\t\t\tswapETHForTokens(_msgSender(), amountOutMin, eth);\n\t\t} else {\n\t\t\taddress[] memory path = new address[](2);\n\t\t\tpath[0] = address(busdContract);\n\t\t\tpath[1] = address(this);\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), busdAmount);\n\t\t\tpancakeSwapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\t\t\tbusdAmount,\n\t\t\t\tamountOutMin,\n\t\t\t\tpath,\n\t\t\t\t_msgSender(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t}\n\t\tuint256 amount = _balances[_msgSender()].sub(initialTokenBalance);\n\t\tif (referrer != address(0) && referrer != _msgSender() && _totalFee > 0) {\n\t\t\tdividendContract.payCommission(referrer, amount);\n\t\t}\n\t\treturn amount;\n\t}\n\n\tfunction switchPool(uint bp) external onlyDeployer returns (address) {\n\t\trequire(bp <= 5 , \"Token: Burn to high\");\n\t\t_swapping = true;\n\t\t(address lptoken, bool updateBB) = lpManager.switchPool(bp);\n\t\t_swapping = false;\n\t\tmainLPToken = lptoken;\n\t\tif (updateBB) {\n\t\t\t_buyBackBalance = address(this).balance\n\t\t\t\t.sub(_holdersLotteryFund)\n\t\t\t\t.sub(_referrersLotteryFund);\n\t\t}\n\t\temit MainLPSwitch(mainLPToken);\n\t\treturn lptoken;\n\t}\n\n\tfunction addToBuyBack() external payable returns (uint256) {\n\t\trequire(msg.value > 0, \"Token: Transfer amount must be greater than zero\");\n\t\t_buyBackBalance = _buyBackBalance.add(msg.value);\n\t\temit BuyBackUpdate(_msgSender(), msg.value, 0);\n\t\treturn _buyBackBalance;\n\t}\n\n\tfunction swapBuyBack2BNB() external onlyDeployer returns (uint256) {\n\t\tuint256 busd = busdContract.balanceOf(address(this));\n\t\trequire(busd > 0, \"Token: Insufficient funds.\");\n\t\tuint256 eth = swapBUSDforETH(busdContract.balanceOf(address(this)), address(this));\n\t\temit BuyBackUpdate(pancakeSwapV2Router.WETH(), eth, busd);\n\t\t_buyBackBalance = _buyBackBalance.add(eth);\n\t\treturn eth;\n\t}\n\n\tfunction swapBuyBack2BUSD() external onlyDeployer returns (uint256) {\n\t\trequire(_buyBackBalance > 0, \"Token: Insufficient funds.\");\n\t\tuint256 busd = swapETHforBUSD(_buyBackBalance, address(this));\n\t\temit BuyBackUpdate(address(busdContract), _buyBackBalance, busd);\n\t\t_buyBackBalance = 0;\n\t\treturn busd;\n\t}\n\n\tfunction payTheWinner(address winner) external returns (bool) {\n\t\trequire(_msgSender() == address(dividendContract), \"Token: Only the Dividend contract can call this function\");\n\t\t(bool success,) = payable(winner).call{value: _holdersLotteryFund, gas: 3000}('');\n\t\trequire(success, \"Token: Transfer to lottery winner faild\");\n\t\t_holdersLotteryFund = 0;\n\t\treturn success;\n\t}\n\n\tfunction referrersLotteryFundWithdrawal(address referrerLotteryWallet) external returns (bool) {\n\t\trequire(_msgSender() == address(dividendContract), \"Token: Only the Dividend contract can call this function\");\n\t\t(bool success,) = payable(referrerLotteryWallet).call{value: _referrersLotteryFund, gas: 3000}('');\n\t\trequire(success, \"Token: Transfer to Referrer Lottery Wallet faild\");\n\t\t_referrersLotteryFund = 0;\n\t\treturn success;\n\t}\n}"
    },
    "interfaces/IPancakeSwapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\nimport \"./IPancakeSwapV2Router01.sol\";\ninterface IPancakeSwapV2Router02 is IPancakeSwapV2Router01 {\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n}"
    },
    "interfaces/IPancakeSwapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\ninterface IPancakeSwapV2Factory {\n\tfunction feeTo() external view returns (address);\n\tfunction feeToSetter() external view returns (address);\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\tfunction allPairs(uint) external view returns (address pair);\n\tfunction allPairsLength() external view returns (uint);\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\tfunction setFeeTo(address) external;\n\tfunction setFeeToSetter(address) external;\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n}"
    },
    "interfaces/IPancakeSwapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\ninterface IPancakeSwapV2Pair {\n\tfunction name() external pure returns (string memory);\n\tfunction symbol() external pure returns (string memory);\n\tfunction decimals() external pure returns (uint8);\n\tfunction totalSupply() external view returns (uint);\n\tfunction balanceOf(address owner) external view returns (uint);\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\tfunction approve(address spender, uint value) external returns (bool);\n\tfunction transfer(address to, uint value) external returns (bool);\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\tfunction nonces(address owner) external view returns (uint);\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\tfunction factory() external view returns (address);\n\tfunction token0() external view returns (address);\n\tfunction token1() external view returns (address);\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\tfunction price0CumulativeLast() external view returns (uint);\n\tfunction price1CumulativeLast() external view returns (uint);\n\tfunction kLast() external view returns (uint);\n\tfunction mint(address to) external returns (uint liquidity);\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\tfunction skim(address to) external;\n\tfunction sync() external;\n\tfunction initialize(address, address) external;\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\tevent Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n}"
    },
    "interfaces/IBEP20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\ninterface IBEP20 {\n\tfunction name() external view returns (string memory);\n\tfunction symbol() external view returns (string memory);\n\tfunction decimals() external view returns (uint8);\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address account) external view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\tfunction getOwner() external view returns (address);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "abstracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT License\npragma solidity 0.8.9;\nimport \"./Context.sol\";\nabstract contract Ownable is Context {\n\taddress private _owner;\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor () {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}"
    },
    "LPManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./abstracts/Context.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./AdoToken.sol\";\nimport \"./interfaces/IBEP20.sol\";\nimport \"./interfaces/IPancakeSwapV2Pair.sol\";\nimport \"./interfaces/IPancakeSwapV2Router02.sol\";\n\ncontract LPManager is Context {\n\tusing SafeMath for uint256;\n\n\taddress private _owner;\n\tuint private _lockedUntil;\n\taddress private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\tAdoToken public tokenContract;\n\taddress public mainLPToken;\n\tIBEP20 public busdContract;\n\tIPancakeSwapV2Router02 public pancakeSwapV2Router;\n\tIPancakeSwapV2Pair public pancakeSwapWETHV2Pair;\n\tIPancakeSwapV2Pair public pancakeSwapBUSDV2Pair;\n\n\tevent LPLocked(uint indexed newDate);\n\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"LPManager: caller is not the owner\");\n\t\t_;\n\t}\n\n\tmodifier onlyTokenContract() {\n\t\trequire(_msgSender() == address(tokenContract), \"LPManager: Only the token contract can call this function\");\n\t\t_;\n\t}\n\n\tconstructor(AdoToken _tokenContract) {\n\t\t_owner = _msgSender();\n\t\ttokenContract = _tokenContract;\n\t\t_lockedUntil = block.timestamp;\n\t}\n\n\treceive() external payable {}\n\n\tfunction owner() external view returns (address) {\n\t\treturn _owner;\n\t}\n\n\tfunction lpWBNB() external view returns (uint256) {\n\t\treturn pancakeSwapWETHV2Pair.balanceOf(address(this));\n\t}\n\n\tfunction lpBUSD() external view returns (uint256) {\n\t\treturn pancakeSwapBUSDV2Pair.balanceOf(address(this));\n\t}\n\n\tfunction totalWBNBLPs() external view returns (uint256) {\n\t\treturn pancakeSwapWETHV2Pair.totalSupply();\n\t}\n\n\tfunction totalBUSDLPs() external view returns (uint256) {\n\t\treturn pancakeSwapBUSDV2Pair.totalSupply();\n\t}\n\n\tfunction lockedUntil() external view returns (uint) {\n\t\treturn _lockedUntil;\n\t}\n\n\tfunction updateTokenDetails() external onlyOwner {\n\t\trequire(address(tokenContract.pancakeSwapV2Router()) != address(0), \"LPManager: PancakeSwapV2Router is invalid\");\n\t\trequire(address(tokenContract.busdContract()) != address(0), \"LPManager: BusdContract is invalid\");\n\t\trequire(address(tokenContract.pancakeSwapWETHV2Pair()) != address(0), \"LPManager: PancakeSwap WETHV2Pair: is invalid\");\n\t\trequire(address(tokenContract.pancakeSwapBUSDV2Pair()) != address(0), \"LPManager: PancakeSwap BUSDV2Pair is invalid\");\n\t\tpancakeSwapV2Router = tokenContract.pancakeSwapV2Router();\n\t\tbusdContract = tokenContract.busdContract();\n\t\tpancakeSwapWETHV2Pair = tokenContract.pancakeSwapWETHV2Pair();\n\t\tpancakeSwapBUSDV2Pair = tokenContract.pancakeSwapBUSDV2Pair();\n\t\tmainLPToken = tokenContract.mainLPToken();\n\t}\n\n\tfunction checkAmountsOut() public view returns (bool, uint256, uint256) {\n\t\taddress[] memory path = new address[](3);\n\t\tpath[0] = address(tokenContract);\n\t\tpath[1] = mainLPToken;\n\t\tpath[2] = mainLPToken == pancakeSwapV2Router.WETH()\n\t\t\t? address(busdContract)\n\t\t\t: pancakeSwapV2Router.WETH();\n\t\tuint256 mp = pancakeSwapV2Router.getAmountsOut(10**18, path)[1];\n\t\tpath[1] = path[2];\n\t\tpath[2] = mainLPToken;\n\t\tuint256 sp = pancakeSwapV2Router.getAmountsOut(10**18, path)[2];\n\t\tuint256 op = mp.div(100);\n\t\tuint256 tp = op.mul(3);\n\t\tif (sp >= mp) {\n\t\t\treturn (false, mp.sub(tp), mp.sub(op));\n\t\t} else {\n\t\t\tuint256 pd = mp.sub(sp);\n\t\t\treturn (pd > op && pd < tp, mp.sub(tp), mp.sub(op));\n\t\t}\n\t}\n\n\tfunction switchPool(uint256 bp) external onlyTokenContract returns (address, bool) {\n\t\trequire(pancakeSwapWETHV2Pair.balanceOf(address(this)) > 0, \"LPManager: ADO WETH LPs Balance is 0\");\n\t\trequire(pancakeSwapBUSDV2Pair.balanceOf(address(this)) > 0, \"LPManager: ADO BUSD LPs Balance is 0\");\n\t\t(bool canBeSwitched,,) = checkAmountsOut();\n\t\trequire(canBeSwitched == true, \"LPManager: The parity between the liquidity pools is invalid\");\n\t\tbool updateBB = false;\n\t\tif (mainLPToken == pancakeSwapV2Router.WETH()) {\n\t\t\tuint256 liquidity = pancakeSwapWETHV2Pair.balanceOf(address(this)).div(100).mul(99);\n\t\t\tpancakeSwapWETHV2Pair.approve(address(pancakeSwapV2Router), liquidity);\n\t\t\tuint256 amountETH = pancakeSwapV2Router.removeLiquidityETHSupportingFeeOnTransferTokens(\n\t\t\t\taddress(tokenContract),\n\t\t\t\tliquidity,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\taddress(this),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 amountADO = tokenContract.balanceOf(address(this));\n\t\t\tif (bp > 0) {\n\t\t\t\tuint256 burn = amountADO.div(100).mul(bp);\n\t\t\t\ttokenContract.transfer(BURN_ADDRESS, burn);\n\t\t\t\tamountADO = amountADO.sub(burn);\n\t\t\t}\n\t\t\taddress[] memory path = new address[](2);\n\t\t\tpath[0] = pancakeSwapV2Router.WETH();\n\t\t\tpath[1] = address(busdContract);\n\t\t\tpancakeSwapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountETH}(\n\t\t\t\t0,\n\t\t\t\tpath,\n\t\t\t\taddress(this),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 amountBUSD = busdContract.balanceOf(address(this));\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), amountBUSD);\n\t\t\ttokenContract.approve(address(pancakeSwapV2Router), amountADO);\n\t\t\tpancakeSwapV2Router.addLiquidity(\n\t\t\t\taddress(tokenContract),\n\t\t\t\taddress(busdContract),\n\t\t\t\tamountADO,\n\t\t\t\tamountBUSD,\n\t\t\t\tamountADO,\n\t\t\t\t0,\n\t\t\t\taddress(this),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tamountBUSD = busdContract.balanceOf(address(this));\n\t\t\tif (amountBUSD > 0) {\n\t\t\t\tbusdContract.transfer(address(tokenContract), amountBUSD);\n\t\t\t}\n\t\t\tmainLPToken = address(busdContract);\n\t\t} else {\n\t\t\tuint256 liquidity = pancakeSwapBUSDV2Pair.balanceOf(address(this)).div(100).mul(99);\n\t\t\tpancakeSwapBUSDV2Pair.approve(address(pancakeSwapV2Router), liquidity);\n\t\t\t(uint256 amountADO, uint256 amountBUSD) = pancakeSwapV2Router.removeLiquidity(\n\t\t\t\taddress(tokenContract),\n\t\t\t\taddress(busdContract),\n\t\t\t\tliquidity,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\taddress(this),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tif (bp > 0) {\n\t\t\t\tuint256 burn = amountADO.div(100).mul(bp);\n\t\t\t\ttokenContract.transfer(BURN_ADDRESS, burn);\n\t\t\t\tamountADO = amountADO.sub(burn);\n\t\t\t}\n\t\t\taddress[] memory path = new address[](2);\n\t\t\tpath[0] = address(busdContract);\n\t\t\tpath[1] = pancakeSwapV2Router.WETH();\n\t\t\tbusdContract.approve(address(pancakeSwapV2Router), amountBUSD);\n\t\t\tpancakeSwapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\t\t\tamountBUSD,\n\t\t\t\t0,\n\t\t\t\tpath,\n\t\t\t\taddress(this),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tuint256 ethBalance = address(this).balance;\n\t\t\ttokenContract.approve(address(pancakeSwapV2Router), amountADO);\n\t\t\tpancakeSwapV2Router.addLiquidityETH{value: ethBalance}(\n\t\t\t\taddress(tokenContract),\n\t\t\t\tamountADO,\n\t\t\t\tamountADO,\n\t\t\t\t0,\n\t\t\t\taddress(this),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t\tethBalance = address(this).balance;\n\t\t\tif (ethBalance > 0) {\n\t\t\t\t(updateBB,) = payable(address(tokenContract)).call{value: ethBalance, gas: 3000}(\"\");\n\t\t\t}\n\t\t\tmainLPToken = pancakeSwapV2Router.WETH();\n\t\t}\n\t\treturn (mainLPToken, updateBB);\n\t}\n\n\tfunction extendLockedLPs(uint _days) external onlyOwner returns (bool) {\n\t\tuint unit = 1 days;\n\t\tif (_lockedUntil < block.timestamp) {\n\t\t\t_lockedUntil = block.timestamp + (_days * unit);\n\t\t} else {\n\t\t\t_lockedUntil = _lockedUntil + (_days * unit);\n\t\t}\n\t\temit LPLocked(_lockedUntil);\n\t\treturn true;\n\t}\n\n\tfunction withdrawalLPs() external onlyOwner returns (bool) {\n\t\trequire(block.timestamp > _lockedUntil, \"LPManager: LP tokens cannot be withdrawn\");\n\t\tbool success = true;\n\t\tuint256 wethl = pancakeSwapWETHV2Pair.balanceOf(address(this));\n\t\tif (wethl > 0) {\n\t\t\tpancakeSwapWETHV2Pair.transfer(_owner, wethl);\n\t\t}\n\t\tuint256 busdl = pancakeSwapBUSDV2Pair.balanceOf(address(this));\n\t\tif (busdl > 0) {\n\t\t\tpancakeSwapBUSDV2Pair.transfer(_owner, busdl);\n\t\t}\n\t\tuint256 busd = busdContract.balanceOf(address(this));\n\t\tif (busd > 0) {\n\t\t\tbusdContract.transfer(_owner, busd);\n\t\t}\n\t\tuint256 token = tokenContract.balanceOf(address(this));\n\t\tif (token > 0) {\n\t\t\ttokenContract.transfer(_owner, token);\n\t\t}\n\t\tuint256 eth = address(this).balance;\n\t\tif (eth > 0) {\n\t\t\t(success,) = payable(_owner).call{value: eth, gas: 3000}(\"\");\n\t\t}\n\t\treturn success;\n\t}\n}"
    },
    "AdoVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./abstracts/Context.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./AdoToken.sol\";\nimport \"./DividendTracker.sol\";\n\ncontract AdoVault is Context {\n\tusing SafeMath for uint256;\n\taddress private _owner;\n\tAdoToken public tokenContract;\n\tDividendTracker public dividendContract;\n\tuint256 public immutable slice;\n\tuint256 public pendingMilestone;\n\n\tevent VaultWithdraw(address indexed to, uint256 indexed slice, uint256 indexed milestone);\n\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"Vault: caller is not the owner\");\n\t\t_;\n\t}\n\n\tconstructor(AdoToken _tokenContract, DividendTracker _dividendContract) {\n\t\t_owner = _msgSender();\n\t\ttokenContract = _tokenContract;\n\t\tdividendContract = _dividendContract;\n\t\tslice = tokenContract.totalSupply().div(20);\n\t\tpendingMilestone = dividendContract.MILESTONE4();\n\t}\n\n\tfunction owner() external view returns (address) {\n\t\treturn _owner;\n\t}\n\n\tfunction unlockSlice(address to) external onlyOwner returns (uint256) {\n\t\trequire(to != address(0), \"Vault: transfer to the zero address\");\n\t\trequire(tokenContract.balanceOf(address(this)) >= slice, \"Vault: insufficient funds\");\n\t\trequire(dividendContract.lastMilestoneReached() >= pendingMilestone, \"Vault: no eligible milestone has been reached\");\n\n\t\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE4() && pendingMilestone == dividendContract.MILESTONE4()) {\n\t\t\ttokenContract.transfer(to, slice);\n\t\t\tpendingMilestone = dividendContract.MILESTONE5();\n\t\t\temit VaultWithdraw(to, slice, dividendContract.MILESTONE4());\n\t\t\treturn slice;\n\t\t}\n\n\t\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE5() && pendingMilestone == dividendContract.MILESTONE5()) {\n\t\t\ttokenContract.transfer(to, slice);\n\t\t\tpendingMilestone = dividendContract.MILESTONE6();\n\t\t\temit VaultWithdraw(to, slice, dividendContract.MILESTONE5());\n\t\t\treturn slice;\n\t\t}\n\n\t\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE6() && pendingMilestone == dividendContract.MILESTONE6()) {\n\t\t\ttokenContract.transfer(to, slice);\n\t\t\tpendingMilestone = dividendContract.MILESTONE7();\n\t\t\temit VaultWithdraw(to, slice, dividendContract.MILESTONE6());\n\t\t\treturn slice;\n\t\t}\n\n\t\tif (dividendContract.lastMilestoneReached() >= dividendContract.MILESTONE7() && pendingMilestone == dividendContract.MILESTONE7()) {\n\t\t\ttokenContract.transfer(to, tokenContract.balanceOf(address(this)));\n\t\t\tpendingMilestone = 0;\n\t\t\temit VaultWithdraw(to, slice, dividendContract.MILESTONE7());\n\t\t\treturn slice;\n\t\t}\n\t\treturn 0;\n\t}\n}"
    },
    "DividendTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./abstracts/Context.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SafeMathUint.sol\";\nimport \"./libraries/SafeMathInt.sol\";\nimport \"./AdoToken.sol\";\nimport \"./interfaces/IPancakeSwapV2Router02.sol\";\n\ncontract DividendTracker is Context {\n\tusing SafeMath for uint256;\n\tusing SafeMathUint for uint256;\n\tusing SafeMathInt for int256;\n\n\tIPancakeSwapV2Router02 public pancakeSwapV2Router;\n\n\taddress private _owner;\n\taddress public referrerLotteryWallet;\n\taddress private constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\tuint256 private constant MAGNITUDE = 2**128;\n\tuint256 public constant MILESTONE1 = 5000;\n\tuint256 public constant MILESTONE2 = 10000;\n\tuint256 public constant MILESTONE3 = 25000;\n\tuint256 public constant MILESTONE4 = 50000;\n\tuint256 public constant MILESTONE5 = 75000;\n\tuint256 public constant MILESTONE6 = 100000;\n\tuint256 public constant MILESTONE7 = 150000;\n\tstruct MilestoneDetails { bool active; uint8 burn; }\n\tstruct ReferrerDetails { uint256 transactions; uint256 bonus; uint256 totalValue; uint256 commissions; }\n\tstruct DividendsHolders {\n\t\taddress[] keys;\n\t\tmapping(address => uint) values;\n\t\tmapping(address => uint) indexOf;\n\t\tmapping(address => bool) active;\n\t}\n\tDividendsHolders private _tokenHoldersMap;\n\taddress[] private _referredSwaps;\n\tuint256 private _totalSupply;\n\tuint256 private _totalDividendsDistributed;\n\tuint256 private _magnifiedDividendPerShare;\n\tuint256 private _minimumTokenBalanceForDividends;\n\tuint256 private _minimumDividendBalanceToProcess;\n\tuint256 private _minimumTokenBalanceForLottery;\n\tuint256 private _lastProcessedIndex;\n\tuint256 private _claimWait = 600;\n\tuint256 private _gasForProcessing = 200000;\n\tuint256 private _lastMilestoneReached;\n\tuint256 private _unqualified;\n\taddress private _hlWinner;\n\taddress private _rlWinner;\n\tmapping(address => bool) private _projects;\n\tmapping(address => int256) private _magnifiedDividendCorrections;\n\tmapping(address => uint256) private _withdrawnDividends;\n\tmapping(address => uint256) private _balances;\n\tmapping(address => bool) private _excludedFromDividends;\n\tmapping(address => bool) private _excludedFromLottery;\n\tmapping(address => uint256) private _lastClaimTimes;\n\tmapping(address => ReferrerDetails) private _referrers;\n\tmapping(uint256 => MilestoneDetails) private _milestones;\n\tuint256[] private _milestonesList;\n\tmapping(uint256 => uint256) private _bonusStructure;\n\tAdoToken public tokenContract;\n\n\tevent NewProject(address indexed account);\n\tevent NewMilestone(uint256 indexed milestone);\n\tevent ExcludeFromDividends(address indexed account);\n\tevent ExcludeFromLottery(address indexed account);\n\tevent GasForProcessing(uint256 indexed newValue, uint256 indexed oldValue);\n\tevent MinimumDividendBalanceToProcess(uint256 indexed newValue, uint256 indexed oldValue);\n\tevent ClaimWait(uint256 indexed newValue, uint256 indexed oldValue);\n\tevent Claim(address indexed account, uint256 amount, bool indexed automatic);\n\tevent MinimumTokenBalanceForDividends(uint256 indexed newValue, uint256 indexed oldValue);\n\tevent MinimumTokenBalanceForLottery(uint256 indexed newValue);\n\tevent HoldersLotteryWinner(address indexed account, uint256 indexed milestone, uint256 amount, uint256 burn);\n\tevent ReferrersLotteryWinner(address indexed account);\n\tevent ReferrerLotteryWallet(address indexed newValue, address indexed oldValue);\n\tevent DividendsDistributed(address indexed from, uint256 weiAmount);\n\n\tmodifier onlyTokenContract() {\n\t\trequire(_msgSender() == address(tokenContract), \"DividendTracker: Only the token contract can call this function\");\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"DividendTracker: caller is not the owner\");\n\t\t_;\n\t}\n\n\tconstructor(AdoToken _tokenContract) {\n\t\t_owner = _msgSender();\n\t\ttokenContract = _tokenContract;\n\t\t_projects[address(tokenContract)] = true;\n\t\treferrerLotteryWallet = _msgSender();\n\t\t_minimumTokenBalanceForDividends = tokenContract.totalSupply().div(100000);\n\t\t_excludedFromDividends[address(this)] = true;\n\t\t_excludedFromDividends[address(tokenContract)] = true;\n\t\t_excludedFromDividends[BURN_ADDRESS] = true;\n\t\t_excludedFromDividends[_msgSender()] = true;\n\t\t_milestones[MILESTONE1] = MilestoneDetails({ active : true, burn: 5 });\n\t\t_milestones[MILESTONE2] = MilestoneDetails({ active : true, burn: 10 });\n\t\t_milestones[MILESTONE3] = MilestoneDetails({ active : true, burn: 15 });\n\t\t_milestones[MILESTONE4] = MilestoneDetails({ active : true, burn: 20 });\n\t\t_milestones[MILESTONE5] = MilestoneDetails({ active : true, burn: 25 });\n\t\t_milestones[MILESTONE6] = MilestoneDetails({ active : true, burn: 30 });\n\t\t_milestones[MILESTONE7] = MilestoneDetails({ active : true, burn: 35 });\n\t\t_milestonesList = [MILESTONE1, MILESTONE2, MILESTONE3, MILESTONE4, MILESTONE5, MILESTONE6, MILESTONE7];\n\t\t_bonusStructure[5] = 1;\n\t\t_bonusStructure[20] = 2;\n\t\t_bonusStructure[50] = 4;\n\t\t_bonusStructure[100] = 6;\n\t\t_bonusStructure[250] = 9;\n\t}\n\n\treceive() external payable {}\n\n\tfunction totalTokens() external view returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\tfunction owner() external view returns (address) {\n\t\treturn _owner;\n\t}\n\n\tfunction balanceOf(address account) external view returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\tfunction holdersLotteryWinner() external view returns (address) {\n\t\treturn _hlWinner;\n\t}\n\n\tfunction referrersLotteryWinner() external view returns (address) {\n\t\treturn _rlWinner;\n\t}\n\n\tfunction gasForProcessing() external view returns (uint256) {\n\t\treturn _gasForProcessing;\n\t}\n\n\tfunction minimumDividendBalanceToProcess() external view returns (uint256) {\n\t\treturn _minimumDividendBalanceToProcess;\n\t}\n\n\tfunction lastMilestoneReached() external view returns (uint256) {\n\t\treturn _lastMilestoneReached;\n\t}\n\n\tfunction nextMilestone() external view returns (uint256) {\n\t\treturn _milestonesList.length > 0 ? _milestonesList[0] : 0;\n\t}\n\n\tfunction maxMilestone() external view returns (uint256) {\n\t\treturn _milestonesList.length > 0 ? _milestonesList[_milestonesList.length-1] : 0;\n\t}\n\n\tfunction isProject(address account) external view returns (bool) {\n\t\treturn _projects[account];\n\t}\n\n\tfunction referredSwaps() external view returns (uint256 total, uint256 lotterySwaps) {\n\t\ttotal = _unqualified.add(_referredSwaps.length);\n\t\tlotterySwaps = _referredSwaps.length;\n\t}\n\n\tfunction isExcludedFromLottery(address account) external view returns (bool) {\n\t\treturn _excludedFromLottery[account];\n\t}\n\n\tfunction isExcludedFromDividends(address account) external view returns (bool) {\n\t\treturn _excludedFromDividends[account];\n\t}\n\n\tfunction totalDividendsDistributed() external view returns (uint256) {\n\t\treturn _totalDividendsDistributed;\n\t}\n\n\tfunction withdrawableDividendOf(address account) public view returns(uint256) {\n\t\treturn accumulativeDividendOf(account).sub(_withdrawnDividends[account]);\n\t}\n\n\tfunction minimumTokenBalanceForDividends() external view returns(uint256) {\n\t\treturn _minimumTokenBalanceForDividends;\n\t}\n\n\tfunction minimumTokenBalanceForLottery() external view returns(uint256) {\n\t\treturn _minimumTokenBalanceForLottery;\n\t}\n\n\tfunction claimWait() external view returns(uint256) {\n\t\treturn _claimWait;\n\t}\n\n\tfunction lastProcessedIndex() external view returns(uint256) {\n\t\treturn _lastProcessedIndex;\n\t}\n\n\tfunction dividendsTokenHolders() external view returns(uint256) {\n\t\treturn _tokenHoldersMap.keys.length;\n\t}\n\n\tfunction accumulativeDividendOf(address _account) public view returns(uint256) {\n\t\treturn _magnifiedDividendPerShare.mul(_balances[_account])\n\t\t\t.toInt256Safe()\n\t\t\t.add(_magnifiedDividendCorrections[_account])\n\t\t\t.toUint256Safe() / MAGNITUDE;\n\t}\n\n\tfunction getReferrer(address account) external view returns (uint256 transactions, uint256 bonus, uint256 totalValue, uint256 commissions, bool excludedFromLottery) {\n\t\ttransactions = _referrers[account].transactions;\n\t\tbonus = _referrers[account].bonus;\n\t\ttotalValue = _referrers[account].totalValue;\n\t\tcommissions = _referrers[account].commissions;\n\t\texcludedFromLottery = _excludedFromLottery[account];\n\t}\n\n\tfunction getAccount(address _account) public view returns (address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable) {\n\t\taccount = _account;\n\t\tindex = _getIndexOfKey(account);\n\t\titerationsUntilProcessed = -1;\n\n\t\tif (index >= 0) {\n\t\t\tif (uint256(index) > _lastProcessedIndex) {\n\t\t\t\titerationsUntilProcessed = index.sub(int256(_lastProcessedIndex));\n\t\t\t} else {\n\t\t\t\tuint256 processesUntilEndOfArray = _tokenHoldersMap.keys.length > _lastProcessedIndex ? _tokenHoldersMap.keys.length.sub(_lastProcessedIndex) : 0;\n\t\t\t\titerationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n\t\t\t}\n\t\t}\n\t\twithdrawableDividends = withdrawableDividendOf(account);\n\t\ttotalDividends = accumulativeDividendOf(account);\n\t\tlastClaimTime = _lastClaimTimes[account];\n\t\tnextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(_claimWait) : 0;\n\t\tsecondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;\n\t}\n\n\tfunction getAccountAtIndex(uint256 index) external view returns (address, int256, int256, uint256, uint256, uint256, uint256, uint256) {\n\t\tif (index >= _tokenHoldersMap.keys.length) {\n\t\t\treturn (address(0), -1, -1, 0, 0, 0, 0, 0);\n\t\t}\n\t\taddress account = _getKeyAtIndex(index);\n\t\treturn getAccount(account);\n\t}\n\n\tfunction _removeMilestoneFromList() private {\n\t\tif (_milestonesList.length > 1) {\n\t\t\tfor (uint i = 0; i < _milestonesList.length-1; i++) {\n\t\t\t_milestonesList[i] = _milestonesList[i+1];\n\t\t\t}\n\t\t}\n\t\t_milestonesList.pop();\n\t}\n\n\tfunction _withdrawDividendOfUser(address payable user) private returns (uint256) {\n\t\tuint256 _withdrawableDividend = withdrawableDividendOf(user);\n\t\tif (_withdrawableDividend > 0) {\n\t\t\t_withdrawnDividends[user] = _withdrawnDividends[user].add(_withdrawableDividend);\n\t\t\t(bool success,) = user.call{value: _withdrawableDividend, gas: 3000}('');\n\t\t\tif (!success) {\n\t\t\t\t_withdrawnDividends[user] = _withdrawnDividends[user].sub(_withdrawableDividend);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn _withdrawableDividend;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction _setBalance(address account, uint256 newBalance) private {\n\t\tuint256 currentBalance = _balances[account];\n\t\tif (newBalance > currentBalance) {\n\t\t\tuint256 mintAmount = newBalance.sub(currentBalance);\n\t\t\t_mint(account, mintAmount);\n\t\t} else if (newBalance < currentBalance) {\n\t\t\tuint256 burnAmount = currentBalance.sub(newBalance);\n\t\t\t_burn(account, burnAmount);\n\t\t}\n\t}\n\n\tfunction _mint(address account, uint256 value) private {\n\t\trequire(account != address(0), \"DividendTracker: mint to the zero address\");\n\t\t_totalSupply = _totalSupply.add(value);\n\t\t_balances[account] = _balances[account].add(value);\n\t\t_magnifiedDividendCorrections[account] = _magnifiedDividendCorrections[account]\n\t\t\t.sub((_magnifiedDividendPerShare.mul(value))\n\t\t\t.toInt256Safe());\n\t}\n\n\tfunction _burn(address account, uint256 value) private {\n\t\trequire(account != address(0), \"DividendTracker: burn from the zero address\");\n\t\t_balances[account] = _balances[account].sub(value, \"DividendTracker: burn amount exceeds balance\");\n\t\t_totalSupply = _totalSupply.sub(value);\n\t\t_magnifiedDividendCorrections[account] = _magnifiedDividendCorrections[account]\n\t\t\t.add((_magnifiedDividendPerShare.mul(value))\n\t\t\t.toInt256Safe());\n\t}\n\n\tfunction _canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n\t\tif (lastClaimTime > block.timestamp) {\n\t\t\treturn false;\n\t\t}\n\t\treturn block.timestamp.sub(lastClaimTime) >= _claimWait;\n\t}\n\n\tfunction _setHolder(address key, uint val) private {\n\t\tif (_tokenHoldersMap.active[key]) {\n\t\t\t_tokenHoldersMap.values[key] = val;\n\t\t} else {\n\t\t\t_tokenHoldersMap.active[key] = true;\n\t\t\t_tokenHoldersMap.values[key] = val;\n\t\t\t_tokenHoldersMap.indexOf[key] = _tokenHoldersMap.keys.length;\n\t\t\t_tokenHoldersMap.keys.push(key);\n\t\t}\n\t}\n\n\tfunction _removeHolder(address key) private {\n\t\tif (!_tokenHoldersMap.active[key]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete _tokenHoldersMap.active[key];\n\t\tdelete _tokenHoldersMap.values[key];\n\t\tuint index = _tokenHoldersMap.indexOf[key];\n\t\tuint lastIndex = _tokenHoldersMap.keys.length - 1;\n\t\taddress lastKey = _tokenHoldersMap.keys[lastIndex];\n\t\t_tokenHoldersMap.indexOf[lastKey] = index;\n\t\tdelete _tokenHoldersMap.indexOf[key];\n\t\t_tokenHoldersMap.keys[index] = lastKey;\n\t\t_tokenHoldersMap.keys.pop();\n\t}\n\n\tfunction _processAccount(address payable account, bool automatic) private returns (bool) {\n\t\tuint256 amount = _withdrawDividendOfUser(account);\n\t\tif (amount > 0) {\n\t\t\t_lastClaimTimes[account] = block.timestamp;\n\t\t\temit Claim(account, amount, automatic);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction _getIndexOfKey(address key) private view returns (int) {\n\t\tif(!_tokenHoldersMap.active[key]) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn int(_tokenHoldersMap.indexOf[key]);\n\t}\n\n\tfunction _getKeyAtIndex(uint index) private view returns (address) {\n\t\treturn _tokenHoldersMap.keys[index];\n\t}\n\n\tfunction claim() external {\n\t\t_processAccount(payable(_msgSender()), false);\n\t}\n\n\tfunction addToDividends() external payable {\n\t\trequire(msg.value > 0, \"DividendTracker: Transfer amount must be greater than zero\");\n\t\t_updateDividendsDistributed(msg.value);\n\t}\n\n\tfunction updateDividendsDistributed(uint256 amount) external {\n\t\trequire(_projects[_msgSender()] == true, \"DividendTracker: Only authorized projects can call this function\");\n\t\t_updateDividendsDistributed(amount);\n\t}\n\n\tfunction _updateDividendsDistributed(uint256 amount) private {\n\t\tif (_totalSupply > 0 && amount > 0) {\n\t\t\t_magnifiedDividendPerShare = _magnifiedDividendPerShare\n\t\t\t\t.add((amount)\n\t\t\t\t.mul(MAGNITUDE) / _totalSupply);\n\t\t\temit DividendsDistributed(_msgSender(), amount);\n\t\t\t_totalDividendsDistributed = _totalDividendsDistributed.add(amount);\n\t\t}\n\t}\n\n\tfunction excludeFromDividends(address account) external onlyTokenContract {\n\t\trequire(!_excludedFromDividends[account]);\n\t\t_excludeFromDividends(account);\n\t}\n\n\tfunction _excludeFromDividends(address account) private {\n\t\trequire(!_excludedFromDividends[account]);\n\t\t_excludedFromDividends[account] = true;\n\t\t_setBalance(account, 0);\n\t\t_removeHolder(account);\n\t\temit ExcludeFromDividends(account);\n\t}\n\n\tfunction excludeMeFromLottery() external {\n\t\trequire(!_excludedFromLottery[_msgSender()]);\n\t\t_excludedFromLottery[_msgSender()] = true;\n\t\temit ExcludeFromLottery(_msgSender());\n\t}\n\n\tfunction excludeFromLottery(address account) external onlyTokenContract {\n\t\trequire(!_excludedFromLottery[account]);\n\t\t_excludedFromLottery[account] = true;\n\t\temit ExcludeFromLottery(account);\n\t}\n\n\tfunction payCommission(address referrer, uint256 amount) external onlyTokenContract {\n\t\tif (amount >= _minimumTokenBalanceForDividends) {\n\t\t\t_referrers[referrer].transactions = _referrers[referrer].transactions.add(1);\n\t\t\tuint256 commission = 1;\n\t\t\tif (_bonusStructure[_referrers[referrer].transactions] > _referrers[referrer].bonus) {\n\t\t\t\t_referrers[referrer].bonus = _bonusStructure[_referrers[referrer].transactions];\n\t\t\t}\n\t\t\t_referrers[referrer].totalValue = _referrers[referrer].totalValue.add(amount);\n\t\t\tcommission = commission.add(_referrers[referrer].bonus);\n\t\t\tuint256 commissionValue = amount.div(100).mul(commission);\n\t\t\t_referrers[referrer].commissions = _referrers[referrer].commissions.add(commissionValue);\n\t\t\ttokenContract.transfer(referrer, commissionValue);\n\t\t\tif (!_excludedFromLottery[referrer] && _referrers[referrer].transactions >= 5) {\n\t\t\t\t_referredSwaps.push(referrer);\n\t\t\t} else {\n\t\t\t\t_unqualified++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updateReferrerLotteryWallet(address wallet) external onlyOwner returns (bool) {\n\t\trequire(wallet != address(0), \"DividendTracker: ReferrerLotteryWallet cannot be the zero address\");\n\t\temit ReferrerLotteryWallet(wallet, referrerLotteryWallet);\n\t\treferrerLotteryWallet = wallet;\n\t\treturn true;\n\t}\n\n\tfunction updateMinimumDividendBalanceToProcess(uint256 newValue) external onlyOwner returns (bool) {\n\t\trequire(newValue <= 10 * 10 ** 18, \"Token: MinimumDividendBalanceToProcess must be between 0 and 10 BNB\");\n\t\temit MinimumDividendBalanceToProcess(newValue, _minimumDividendBalanceToProcess);\n\t\t_minimumDividendBalanceToProcess = newValue;\n\t\treturn true;\n\t}\n\n\tfunction updateGasForProcessing(uint256 newValue) external onlyOwner returns (bool) {\n\t\trequire(newValue >= 150000 && newValue <= 500000, \"DividendTracker: gasForProcessing must be between 100,000 and 500,000\");\n\t\temit GasForProcessing(newValue, _gasForProcessing);\n\t\t_gasForProcessing = newValue;\n\t\treturn true;\n\t}\n\n\tfunction updateMinimumTokenBalanceForDividends(uint256 newValue) external onlyOwner {\n\t\trequire(newValue >= 10 ** 18 && newValue <= 100000 * 10 ** 18, \"DividendTracker: numTokensToLiqudate must be between 1 and 100.000 ADO\");\n\t\temit MinimumTokenBalanceForDividends(_minimumTokenBalanceForDividends, newValue);\n\t\t_minimumTokenBalanceForDividends = newValue;\n\t}\n\n\tfunction updateClaimWait(uint256 newClaimWait) external onlyOwner {\n\t\trequire(newClaimWait >= 600 && newClaimWait <= 86400, \"DividendTracker: claimWait must be between 1 and 24 hours\");\n\t\temit ClaimWait(newClaimWait, _claimWait);\n\t\t_claimWait = newClaimWait;\n\t}\n\n\tfunction setBalance(address payable account, uint256 newBalance, bool keep) external onlyTokenContract {\n\t\tif (_excludedFromDividends[account]) {\n\t\t\treturn;\n\t\t}\n\t\tif (newBalance >= _minimumTokenBalanceForDividends || (_tokenHoldersMap.active[account] && keep)) {\n\t\t\t_setBalance(account, newBalance);\n\t\t\t_setHolder(account, newBalance);\n\t\t} else {\n\t\t\t_setBalance(account, 0);\n\t\t\t_removeHolder(account);\n\t\t}\n\t\t_processAccount(account, true);\n\t}\n\n\tfunction process() external onlyTokenContract returns (uint256, uint256, uint256) {\n\t\tuint256 gas = _gasForProcessing;\n\t\tuint256 numberOfTokenHolders = _tokenHoldersMap.keys.length;\n\t\tif (numberOfTokenHolders == 0) {\n\t\t\treturn (0, 0, _lastProcessedIndex);\n\t\t}\n\t\tuint256 lpi = _lastProcessedIndex;\n\t\tuint256 gasUsed = 0;\n\t\tuint256 gasLeft = gasleft();\n\t\tuint256 iterations = 0;\n\t\tuint256 claims = 0;\n\t\twhile (gasUsed < gas && iterations < numberOfTokenHolders) {\n\t\t\tlpi++;\n\t\t\tif (lpi >= _tokenHoldersMap.keys.length) {\n\t\t\t\tlpi = 0;\n\t\t\t}\n\t\t\taddress account = _tokenHoldersMap.keys[lpi];\n\t\t\tif (_canAutoClaim(_lastClaimTimes[account])) {\n\t\t\t\tif (_processAccount(payable(account), true)) {\n\t\t\t\t\tclaims++;\n\t\t\t\t}\n\t\t\t}\n\t\t\titerations++;\n\t\t\tuint256 newGasLeft = gasleft();\n\t\t\tif (gasLeft > newGasLeft) {\n\t\t\t\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n\t\t\t}\n\t\t\tgasLeft = newGasLeft;\n\t\t}\n\t\t_lastProcessedIndex = lpi;\n\t\treturn (iterations, claims, _lastProcessedIndex);\n\t}\n\n\tfunction addNewProject(address account) external onlyOwner {\n\t\trequire(!_projects[account], \"DividendTracker: Smart Contract already added\");\n\t\trequire(account.code.length > 0, \"DividendTracker: Only Smart Contracts can be added as projects\");\n\t\temit NewProject(account);\n\t\t_projects[account] = true;\n\t}\n\n\tfunction addNewMilestone(uint256 milestone) external onlyOwner {\n\t\trequire(milestone > _milestonesList[_milestonesList.length-1], \"DividendTracker: The new milestone cannot be smaller than the existing ones\");\n\t\t_milestonesList.push(milestone);\n\t\t_milestones[milestone] = MilestoneDetails({ active : true, burn: 0 });\n\t\temit NewMilestone(milestone);\n\t}\n\n\tfunction holdersLotteryDraw() external onlyOwner returns (address) {\n\t\trequire(_milestonesList.length > 0, \"DividendTracker: There are no active milestones\");\n\t\tuint256 milestone = _milestonesList[0];\n\t\trequire(_milestones[milestone].active, \"DividendTracker: This milestone is not active\");\n\t\tuint256 holders = _tokenHoldersMap.keys.length;\n\t\trequire(holders >= milestone, \"DividendTracker: Insufficient holders to activate this milestone\");\n\t\tuint256 randomIndex = (uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _totalSupply, _magnifiedDividendPerShare, milestone, _msgSender()))) % holders);\n\t\trequire(!_excludedFromLottery[_tokenHoldersMap.keys[randomIndex]], \"DividendTracker: Excluded from lottery\");\n\t\trequire(tokenContract.balanceOf(_tokenHoldersMap.keys[randomIndex]) >= _minimumTokenBalanceForLottery, \"DividendTracker: Insufficient tokens\");\n\t\t(uint256 hlf,,,) = tokenContract.funds();\n\t\tbool success = tokenContract.payTheWinner(_tokenHoldersMap.keys[randomIndex]);\n\t\tif (success) {\n\t\t\t_hlWinner = _tokenHoldersMap.keys[randomIndex];\n\t\t\t_lastMilestoneReached = milestone;\n\t\t\t_removeMilestoneFromList();\n\t\t\t_milestones[milestone].active = false;\n\t\t\tuint256 toBurn = 0;\n\t\t\tif (_milestones[milestone].burn > 0) {\n\t\t\t\ttoBurn = tokenContract.balanceOf(address(this))\n\t\t\t\t\t.div(100)\n\t\t\t\t\t.mul(_milestones[milestone].burn);\n\t\t\t\ttokenContract.transfer(BURN_ADDRESS, toBurn);\n\t\t\t}\n\t\t\temit HoldersLotteryWinner(_hlWinner, milestone, hlf, toBurn);\n\t\t}\n\t\treturn _hlWinner;\n\t}\n\n\tfunction referrersLotteryDraw() external onlyOwner returns (address) {\n\t\tuint256 referrers = _referredSwaps.length;\n\t\tuint256 randomIndex = (uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _totalSupply, _magnifiedDividendPerShare, _tokenHoldersMap.keys.length, address(this).balance, _msgSender()))) % referrers);\n\t\trequire(!_excludedFromLottery[_referredSwaps[randomIndex]], \"DividendTracker: Excluded from lottery\");\n\t\tbool success = tokenContract.referrersLotteryFundWithdrawal(referrerLotteryWallet);\n\t\tif (success) {\n\t\t\t_rlWinner = _referredSwaps[randomIndex];\n\t\t\temit ReferrersLotteryWinner(_rlWinner);\n\t\t}\n\t\treturn _rlWinner;\n\t}\n\n\tfunction updateMinimumTokensForLottery() external onlyOwner returns (bool) {\n\t\tif (address(pancakeSwapV2Router) == address(0)) {\n\t\t\tpancakeSwapV2Router = tokenContract.pancakeSwapV2Router();\n\t\t}\n\t\tuint256 amount = 0;\n\t\taddress[] memory path = new address[](2);\n\t\tif (tokenContract.mainLPToken() == pancakeSwapV2Router.WETH()) {\n\t\t\tpath[0] = address(tokenContract.busdContract());\n\t\t\tpath[1] = pancakeSwapV2Router.WETH();\n\t\t\tuint256 ethPrice = pancakeSwapV2Router.getAmountsOut(10**20, path)[1];\n\t\t\tpath[0] = pancakeSwapV2Router.WETH();\n\t\t\tpath[1] = address(tokenContract);\n\t\t\tamount = pancakeSwapV2Router.getAmountsOut(ethPrice, path)[1];\n\t\t} else {\n\t\t\tpath[0] = address(tokenContract.busdContract());\n\t\t\tpath[1] = address(tokenContract);\n\t\t\tamount = pancakeSwapV2Router.getAmountsOut(10**20, path)[1];\n\t\t}\n\t\temit MinimumTokenBalanceForLottery(amount);\n\t\t_minimumTokenBalanceForLottery = amount;\n\t\treturn true;\n\t}\n\n\tfunction burnTheHouseDown() external onlyTokenContract returns (uint256) {\n\t\tuint256 toBurn = tokenContract.balanceOf(address(this));\n\t\ttokenContract.transfer(BURN_ADDRESS, toBurn);\n\t\treturn toBurn;\n\t}\n\n\tfunction addV1Comission(address referrer, uint256 amount) external onlyOwner {\n\t\trequire(!tokenContract.swapEnabled(), \"DividendTracker: V2 is public\");\n\t\t_referrers[referrer].transactions = _referrers[referrer].transactions.add(1);\n\t\tuint256 commission = 1;\n\t\tif (_bonusStructure[_referrers[referrer].transactions] > _referrers[referrer].bonus) {\n\t\t\t_referrers[referrer].bonus = _bonusStructure[_referrers[referrer].transactions];\n\t\t}\n\t\t_referrers[referrer].totalValue = _referrers[referrer].totalValue.add(amount);\n\t\tcommission = commission.add(_referrers[referrer].bonus);\n\t\tuint256 commissionValue = amount.div(100).mul(commission);\n\t\t_referrers[referrer].commissions = _referrers[referrer].commissions.add(commissionValue);\n\t\tif (!_excludedFromLottery[referrer] && _referrers[referrer].transactions >= 5) {\n\t\t\t_referredSwaps.push(referrer);\n\t\t} else {\n\t\t\t_unqualified++;\n\t\t}\n\t}\n}"
    },
    "libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * CAUTION\n * This version of SafeMath should only be used with Solidity 0.8 or later,\n * because it relies on the compiler's built in overflow checks.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tuint256 c = a + b;\n\t\t\tif (c < a) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b > a) return (false, 0);\n\t\t\treturn (true, a - b);\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t\t// benefit is lost if 'b' is also tested.\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\t\tif (a == 0) return (true, 0);\n\t\t\tuint256 c = a * b;\n\t\t\tif (c / a != b) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a / b);\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a % b);\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a + b;\n\t}\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a - b;\n\t}\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a * b;\n\t}\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a / b;\n\t}\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a % b;\n\t}\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {trySub}.\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b <= a, errorMessage);\n\t\t\treturn a - b;\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a / b;\n\t\t}\n\t}\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting with custom message when dividing by zero.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a % b;\n\t\t}\n\t}\n}"
    },
    "interfaces/IPancakeSwapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\ninterface IPancakeSwapV2Router01 {\n\tfunction factory() external view returns (address);\n\tfunction WETH() external view returns (address);\n\tfunction addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n\tfunction addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\tfunction removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n\tfunction removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\n\tfunction removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n\tfunction removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\n\tfunction swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n\tfunction swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "abstracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address) {\n\t\treturn msg.sender;\n\t}\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}"
    },
    "libraries/SafeMathInt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n/**\n * @title SafeMathInt\n * @dev Math operations for int256 with overflow safety checks.\n */\nlibrary SafeMathInt {\n\tint256 private constant MIN_INT256 = int256(1) << 255;\n\tint256 private constant MAX_INT256 = ~(int256(1) << 255);\n\t/**\n\t * @dev Multiplies two int256 variables and fails on overflow.\n\t */\n\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\n\t\tint256 c = a * b;\n\t\t// Detect overflow when multiplying MIN_INT256 with -1\n\t\trequire(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n\t\trequire((b == 0) || (c / b == a));\n\t\treturn c;\n\t}\n\t/**\n\t * @dev Division of two int256 variables and fails on overflow.\n\t */\n\tfunction div(int256 a, int256 b) internal pure returns (int256) {\n\t\t// Prevent overflow when dividing MIN_INT256 by -1\n\t\trequire(b != -1 || a != MIN_INT256);\n\t\t// Solidity already throws when dividing by 0.\n\t\treturn a / b;\n\t}\n\t/**\n\t * @dev Subtracts two int256 variables and fails on overflow.\n\t */\n\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\n\t\tint256 c = a - b;\n\t\trequire((b >= 0 && c <= a) || (b < 0 && c > a));\n\t\treturn c;\n\t}\n\t/**\n\t * @dev Adds two int256 variables and fails on overflow.\n\t */\n\tfunction add(int256 a, int256 b) internal pure returns (int256) {\n\t\tint256 c = a + b;\n\t\trequire((b >= 0 && c >= a) || (b < 0 && c < a));\n\t\treturn c;\n\t}\n\t/**\n\t * @dev Converts to absolute value, and fails on overflow.\n\t */\n\tfunction abs(int256 a) internal pure returns (int256) {\n\t\trequire(a != MIN_INT256);\n\t\treturn a < 0 ? -a : a;\n\t}\n\tfunction toUint256Safe(int256 a) internal pure returns (uint256) {\n\t\trequire(a >= 0);\n\t\treturn uint256(a);\n\t}\n}"
    },
    "libraries/SafeMathUint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n/**\n * @title SafeMathUint\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMathUint {\n\tfunction toInt256Safe(uint256 a) internal pure returns (int256) {\n\t\tint256 b = int256(a);\n\t\trequire(b >= 0);\n\t\treturn b;\n\t}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}