{{
  "language": "Solidity",
  "sources": {
    "contracts/pp2/P22Token.sol": {
      "content": "/**\n *Submitted for verification at BscScan.com on 2022-04-29\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\ninterface IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {size := extcodesize(account)}\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success,) = recipient.call{value : amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract Ownable is Context {\n    address internal _owner;\n    address private _lastOwner;\n    uint256 public olt;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function lockOwner(uint256 time) public onlyOwner {\n        olt = block.timestamp + time;\n        _lastOwner = _owner;\n        _owner = address(0);\n        emit OwnershipTransferred(_owner, address(0));\n    }\n\n    function lastOwner() public view returns (address) {\n        require(_lastOwner == _msgSender(), \"Ownable: permission denied\");\n        return _lastOwner;\n    }\n\n    function unLockOwner() public {\n        require(_lastOwner == _msgSender(), \"Ownable: permission denied\");\n        require(block.timestamp >= olt, \"Ownable: permission denied\");\n        _owner = _lastOwner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n    external\n    returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external\n    returns (\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value : value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\nlibrary EnumerableSet {\n\n    struct Set {\n        bytes32[] _values;\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {// Equivalent to contains(set, value)\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            // All indexes are 1-based\n\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\ninterface IUniswapV2Pair {\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function sync() external;\n}\n\ncontract TokenReceiver {\n    address public owner;\n    address public spender;\n    address public token;\n    constructor (address token_, address spender_, address owner_) public {\n        owner = owner_;\n        spender = spender_;\n        token = token_;\n        IERC20(token).approve(spender, 10 ** 12 * 10 ** 18);\n    }\n    function increase() public {\n        require(msg.sender == owner, \"permission denied\");\n        IERC20(token).approve(spender, 10 ** 12 * 10 ** 18);\n    }\n\n    function donateDust(address addr, uint256 amount) public {\n        require(msg.sender == owner, \"permission denied\");\n        TransferHelper.safeTransfer(addr, msg.sender, amount);\n    }\n\n    function donateEthDust(uint256 amount) public {\n        require(msg.sender == owner, \"permission denied\");\n        TransferHelper.safeTransferETH(msg.sender, amount);\n    }\n\n    function transferOwner(address newOwner) public {\n        require(msg.sender == owner, \"permission denied\");\n        owner = newOwner;\n    }\n}\n\ncontract MintPoolHelper {\n    address public owner;\n\n    constructor(address owner_) public {\n        owner = owner_;\n    }\n\n    function donateDust(address addr, uint256 amount) public {\n        require(msg.sender == owner, \"permission denied\");\n        TransferHelper.safeTransfer(addr, msg.sender, amount);\n    }\n\n    function donateEthDust(uint256 amount) public {\n        require(msg.sender == owner, \"permission denied\");\n        TransferHelper.safeTransferETH(msg.sender, amount);\n    }\n\n    function transferOwner(address newOwner) public {\n        require(msg.sender == owner, \"permission denied\");\n        owner = newOwner;\n    }\n}\n\ninterface IP22IDO {\n    function updateSpeed(address account, uint256 speed) external;\n\n    function update(address account, uint256 reward) external;\n}\n\ninterface IP22Dividends {\n    function distributeDividends() external;\n}\n\ninterface IP22LP {\n    function dividends(uint256 amount) external;\n}\n\ninterface IRelationshipList {\n    function referee(address account) external view returns (address);\n\n    function root() external view returns (address);\n\n    function refers(address account, uint256 skip, uint256 num) external view returns (address[] memory nodes, uint256 count);\n\n    function isActive(address account) external view returns (bool);\n\n    function allRefers(address account) external view returns (address[] memory);\n}\n\ninterface IMintingPool {\n    function update(address account, uint256 oldBalance, uint256 oldTimestamp) external;\n}\n\n\ncontract P22Token is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(address => bool) private _isExcludedFromFee;\n\n    uint8 private _decimals = 9;\n    uint256 private _tTotal = 21000000 * 10 ** 9;\n\n    string private _name = \"AIGC\";\n    string private _symbol = \"AIGC\";\n\n    uint256 public _buyBurnFee = 10;\n    uint256 public _buyMkFee = 25;\n    uint256 public _buyLpFee = 25;\n    uint256 public totalBuyFee = 60;\n\n    uint256 public _sellBurnFee = 10;\n    uint256 public _sellMkFee = 25;\n    uint256 public _sellLpFee = 25;\n    uint256 public totalSellFee = 60;\n\n    uint public mkTxAmount = 5 * 10 ** 9;\n    uint public lpTxAmount = 5 * 10 ** 9;\n\n    address public marketAddress;\n    address public tokenReceiver;\n\n    IUniswapV2Router02 public uniswapV2Router;\n\n    mapping(address => bool) public ammPairs;\n\n    bool inSwapAndLiquify;\n\n    address public uniswapV2Pair;\n    address public usdt;\n    address public holder;\n\n    uint public lpAmount;\n    uint public mkAmount;\n\n    struct Interest {\n        uint256 index;\n        uint256 period;\n        uint256 lastSendTime;\n        uint minAward;\n        uint award;\n        uint sendCount;\n        IERC20 token;\n        EnumerableSet.AddressSet tokenHolder;\n    }\n\n    address  fromAddress;\n    address  toAddress;\n    Interest internal lpInterest;\n\n    uint public addPriceTokenAmount = 10000;\n\n    // --------------------------------------\n    address public relation;\n    address public ido;\n    address public dividends;\n    address public lp;\n\n\n    mapping(address => bool) public ibf;\n    mapping(address => bool) public ibt;\n    mapping(address => bool) public iwf;\n    mapping(address => bool) public iwt;\n\n    uint256[] public validHoldValues = [100 * 10 ** 9, 1001 * 10 ** 9, 2001 * 10 ** 9, 3001 * 10 ** 9, 4001 * 10 ** 9, 5001 * 10 ** 9];\n    uint256[] public accRates = [0, 50, 100, 150, 200, 300];\n    mapping(address => uint256) public reverseUpTimeIndex;\n    uint256 public rewardEveryDayCoff = 5;\n    uint256 public rewardIdoCoff = 5;\n    uint256 public idoLpAccLimit = 4000;\n    uint256 public idoLpAccValue = 5;\n\n    uint256 public constant PRECISION = 1000;\n    uint256 public constant SEC_TO_DAY = 86400;\n\n    address public mintPool;\n    uint256 public startMintTime;\n    uint256 public mintMode = 0;\n    mapping(address => uint256) public mintReward;\n\n    constructor (\n        address _route,\n        address _usdt,\n        address _holder,\n        address _mkAddress,\n        address _relation,\n        address _ido,\n        address _dividends,\n        address _lp\n    ) public {\n\n        usdt = _usdt;\n        holder = _holder;\n        marketAddress = _mkAddress;\n        // add external contract\n        relation = _relation;\n        ido = _ido;\n        lp = _lp;\n        dividends = _dividends;\n\n        _tOwned[holder] = _tTotal.div(2);\n\n        _isExcludedFromFee[_holder] = true;\n        _isExcludedFromFee[address(this)] = true;\n\n        uniswapV2Router = IUniswapV2Router02(_route);\n\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\n        .createPair(address(this), usdt);\n\n        ammPairs[uniswapV2Pair] = true;\n        tokenReceiver = address(new TokenReceiver(address(usdt), address(this), msg.sender));\n        mintPool = address(new MintPoolHelper(msg.sender));\n//        mintPool = address(0);\n\n        _tOwned[mintPool] = _tTotal.div(2);\n\n        _owner = msg.sender;\n\n        setStatus(uniswapV2Pair, 0, 0, true);\n        setStatus(uniswapV2Pair, 0, 1, true);\n        setStatus(_owner, 1, 0, true);\n        setStatus(_owner, 1, 1, true);\n\n        _isExcludedFromFee[_ido] = true;\n        _isExcludedFromFee[_dividends] = true;\n        _isExcludedFromFee[_lp] = true;\n\n        lpInterest.token = IERC20(uniswapV2Pair);\n        lpInterest.lastSendTime = block.timestamp;\n        lpInterest.minAward = 1e3;\n        lpInterest.period = 3600;\n        lpInterest.sendCount = 50;\n        emit Transfer(address(0), _holder, _tTotal.div(2));\n        emit Transfer(address(0), mintPool, _tTotal.div(2));\n    }\n\n    struct InterestInfo {\n        uint period;\n        uint lastSendTime;\n        uint award;\n        uint count;\n        uint sendNum;\n    }\n\n    function getInterestInfo() external view returns (\n        uint256 period,\n        uint256 lastSendTime,\n        uint award,\n        uint count,\n        uint sendNum\n    ){\n        period = lpInterest.period;\n        lastSendTime = lpInterest.lastSendTime;\n        award = lpInterest.award;\n        count = lpInterest.tokenHolder.length();\n        sendNum = lpInterest.sendCount;\n    }\n\n    function isLpHolder(address account) public view returns (bool) {\n        return lpInterest.tokenHolder.contains(account);\n    }\n\n    function setInterest(uint lpMa, uint lpP, uint lpsc) external onlyOwner {\n        lpInterest.minAward = lpMa;\n        lpInterest.period = lpP;\n        lpInterest.sendCount = lpsc;\n    }\n\n    function setAmmPair(address pair, bool hasPair) external onlyOwner {\n        ammPairs[pair] = hasPair;\n    }\n\n    function setTxAmount(uint mta, uint lta, uint apta) external onlyOwner {\n        mkTxAmount = mta;\n        lpTxAmount = lta;\n        addPriceTokenAmount = apta;\n    }\n\n    function name() public override view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public override view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public override view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _tOwned[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function excludeFromFee(address[] memory accounts) public onlyOwner {\n        for (uint i = 0; i < accounts.length; i++) {\n            _isExcludedFromFee[accounts[i]] = true;\n        }\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n    function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    receive() external payable {}\n\n\n    function _take(uint256 tValue, address from, address to) private {\n        _tOwned[to] = _tOwned[to].add(tValue);\n        emit Transfer(from, to, tValue);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    struct Param {\n        bool takeFee;\n        uint tTransferAmount;\n        uint tMk;\n        uint tLp;\n        uint tBurn;\n        bool isBuy;\n    }\n\n    function _initParam(uint256 tAmount, Param memory param) private view {\n        uint tFee = 0;\n        if (param.takeFee) {\n\n            if (param.isBuy) {\n                param.tMk = tAmount.mul(_buyMkFee).div(PRECISION);\n                param.tLp = tAmount.mul(_buyLpFee).div(PRECISION);\n                param.tBurn = tAmount.mul(_buyBurnFee).div(PRECISION);\n                tFee = tAmount.mul(totalBuyFee).div(PRECISION);\n            } else {\n                param.tMk = tAmount.mul(_sellMkFee).div(PRECISION);\n                param.tLp = tAmount.mul(_sellLpFee).div(PRECISION);\n                param.tBurn = tAmount.mul(_sellBurnFee).div(PRECISION);\n                tFee = tAmount.mul(totalSellFee).div(PRECISION);\n            }\n        }\n        param.tTransferAmount = tAmount.sub(tFee);\n    }\n\n    function _takeFee(Param memory param, address from) private {\n        if (param.tMk > 0) {\n            _take(param.tMk, from, address(this));\n            mkAmount += param.tMk;\n        }\n        if (param.tLp > 0) {\n            _take(param.tLp, from, address(this));\n            lpAmount += param.tLp;\n        }\n        if (param.tBurn > 0) {\n            _take(param.tBurn, from, address(0));\n        }\n    }\n\n    function debug() public view returns (address token0, uint r0, uint bal0) {\n        token0 = IUniswapV2Pair(address(uniswapV2Pair)).token0();\n        if (token0 == usdt) {\n            (r0,,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\n            bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\n        } else {\n            token0 = IUniswapV2Pair(address(uniswapV2Pair)).token1();\n            (, r0,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\n            bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\n        }\n    }\n\n    function _isLiquidity(address from, address to) internal view returns (bool isAdd, bool isDel) {\n        address token0 = IUniswapV2Pair(address(uniswapV2Pair)).token0();\n        uint r0;\n        uint bal0;\n        if (token0 == usdt) {\n            (r0,,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\n            bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\n        } else {\n            token0 = IUniswapV2Pair(address(uniswapV2Pair)).token1();\n            (, r0,) = IUniswapV2Pair(address(uniswapV2Pair)).getReserves();\n            bal0 = IERC20(token0).balanceOf(address(uniswapV2Pair));\n        }\n        if (ammPairs[to]) {\n            if (token0 != address(this) && bal0 > r0) {\n                isAdd = bal0 - r0 > addPriceTokenAmount;\n            }\n        }\n        if (ammPairs[from]) {\n            if (token0 != address(this) && bal0 < r0) {\n                isDel = r0 - bal0 > 0;\n            }\n        }\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        require(!ibf[from] || iwt[to], \"ERC20: transfer refuse by from\");\n        require(!ibt[to] || iwf[from], \"ERC20: transfer refuse by to\");\n\n        bool isAddLiquidity;\n        bool isDelLiquidity;\n        (isAddLiquidity, isDelLiquidity) = _isLiquidity(from, to);\n\n        bool hasLiquidity = IERC20(uniswapV2Pair).totalSupply() > 1000;\n\n        if (from != address(this)\n            && !inSwapAndLiquify\n            && !ammPairs[from]\n            && !isAddLiquidity\n            && hasLiquidity\n        ) {\n            inSwapAndLiquify = true;\n            if (lpAmount >= lpTxAmount && lpAmount <= balanceOf(address(this))) {\n                uint v = lpAmount;\n                lpAmount = 0;\n                swapTokensForToken(v);\n            }\n            if (mkAmount >= mkTxAmount && mkAmount <= balanceOf(address(this))) {\n                uint v = mkAmount;\n                mkAmount = 0;\n                swapTokensToMarket(v);\n            }\n            inSwapAndLiquify = false;\n        }\n        Param memory param;\n        bool takeFee = false;\n\n        if (ammPairs[from] && !_isExcludedFromFee[to] && !isDelLiquidity) {\n            takeFee = true;\n            param.isBuy = true;\n        }\n\n        if (ammPairs[to] && !_isExcludedFromFee[from] && !isAddLiquidity) {\n            takeFee = true;\n        }\n\n        param.takeFee = takeFee;\n        _initParam(amount, param);\n\n        _tokenTransfer(from, to, amount, param);\n\n        if (fromAddress == address(0)) fromAddress = from;\n        if (toAddress == address(0)) toAddress = to;\n        if (!ammPairs[fromAddress]) {\n            setEst(lpInterest, fromAddress);\n        }\n        if (!ammPairs[toAddress]) {\n            setEst(lpInterest, toAddress);\n        }\n        fromAddress = from;\n        toAddress = to;\n\n        if (\n            from != address(this)\n            && lpInterest.lastSendTime + lpInterest.period < block.timestamp\n            && lpInterest.award > 0\n            && lpInterest.award <= IERC20(usdt).balanceOf(address(this))\n            && lpInterest.token.totalSupply() > 1e5) {\n\n            lpInterest.lastSendTime = block.timestamp;\n            processEst();\n\n            // distribute\n            try IP22Dividends(dividends).distributeDividends() {} catch {}\n        }\n    }\n\n    function swapTokensToMarket(uint256 tokenAmount) private {\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = usdt;\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            marketAddress,\n            block.timestamp\n        );\n    }\n\n    function swapTokensForToken(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = usdt;\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            tokenReceiver,\n            block.timestamp\n        );\n        uint bal = IERC20(usdt).balanceOf(tokenReceiver);\n        IERC20(usdt).transferFrom(tokenReceiver, address(this), bal);\n        lpInterest.award = IERC20(usdt).balanceOf(address(this));\n    }\n\n    // update balance\n    function _syncBalance(address account, uint256 oldBalance) private {\n        if (mintMode == 0) {\n            // mode 1 start\n            address referee = IRelationshipList(relation).referee(account);\n            if (block.timestamp <= reverseUpTimeIndex[account]) {\n                return;\n            }\n            if (startMintTime == 0) {\n                reverseUpTimeIndex[account] = block.timestamp;\n                return;\n            }\n            if (referee == address(0)) {\n                reverseUpTimeIndex[account] = block.timestamp;\n                return;\n            }\n            if (reverseUpTimeIndex[account] < startMintTime) {\n                reverseUpTimeIndex[account] = startMintTime;\n            }\n            if (block.timestamp <= reverseUpTimeIndex[account]) {\n                reverseUpTimeIndex[account] = block.timestamp;\n                return;\n            }\n            if (oldBalance > 0) {\n                uint256 throughTime = block.timestamp.sub(reverseUpTimeIndex[account]);\n                uint256 reward = oldBalance.mul(rewardEveryDayCoff).mul(throughTime).div(PRECISION).div(SEC_TO_DAY);\n                uint256 idoReward = oldBalance.mul(rewardIdoCoff).mul(throughTime).div(PRECISION).div(SEC_TO_DAY);\n                try IP22IDO(ido).update(referee, idoReward) {} catch {}\n                if (balanceOf(referee) > validHoldValues[0]) {\n                    for (uint256 i = validHoldValues.length - 1; i > 0; i--) {\n                        if (balanceOf(referee) > validHoldValues[i]) {\n                            reward = reward + reward.mul(accRates[i]).div(PRECISION);\n                            break;\n                        }\n                    }\n                    mintReward[referee] = mintReward[referee] + reward;\n                }\n            }\n            reverseUpTimeIndex[account] = block.timestamp;\n        } else if (mintMode == 1) {\n            try IMintingPool(mintPool).update(account, oldBalance, reverseUpTimeIndex[account]) {} catch {}\n            reverseUpTimeIndex[account] = block.timestamp;\n        }\n    }\n\n    function claim() public {\n        require(mintMode == 0, \"mintMode != 0\");\n        address account = _msgSender();\n        uint256 oldBalance = balanceOf(account);\n        if (_tOwned[mintPool] >= mintReward[account]) {\n            _tOwned[mintPool] = _tOwned[mintPool].sub(mintReward[account]);\n            _tOwned[account] = _tOwned[account].add(mintReward[account]);\n            emit Transfer(mintPool, account, mintReward[account]);\n            mintReward[account] = 0;\n        }\n        _syncBalance(account, oldBalance);\n    }\n\n    function _gain(address[] memory accounts) private {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _syncBalance(accounts[i], balanceOf(accounts[i]));\n        }\n    }\n\n    function gain() public {\n        require(mintMode == 0, \"mintMode != 0\");\n        address account = _msgSender();\n        address[] memory nodes = IRelationshipList(relation).allRefers(account);\n        _gain(nodes);\n    }\n\n    function helpClaim(address[] memory accounts) public onlyOwner {\n        require(mintMode == 0, \"mintMode != 0\");\n        _gain(accounts);\n    }\n\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, Param memory param) private {\n        uint256 oldSenderBalance = _tOwned[sender];\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _syncBalance(sender, oldSenderBalance);\n\n        uint256 oldRecipientBalance = _tOwned[recipient];\n        _tOwned[recipient] = _tOwned[recipient].add(param.tTransferAmount);\n        _syncBalance(recipient, oldRecipientBalance);\n\n        emit Transfer(sender, recipient, param.tTransferAmount);\n        if (param.takeFee) {\n            _takeFee(param, sender);\n        }\n    }\n\n    function donateDust(address addr, uint256 amount) external onlyOwner {\n        TransferHelper.safeTransfer(addr, _msgSender(), amount);\n    }\n\n    function donateEthDust(uint256 amount) external onlyOwner {\n        TransferHelper.safeTransferETH(_msgSender(), amount);\n    }\n\n    function requireMore(uint256 value) public onlyOwner {\n        _tTotal = _tTotal.add(value);\n        _tOwned[msg.sender] = _tOwned[msg.sender].add(value);\n        emit Transfer(address(0), msg.sender, value);\n    }\n\n    function processEst() private {\n        uint256 shareholderCount = lpInterest.tokenHolder.length();\n\n        if (shareholderCount == 0) return;\n\n        uint256 nowbanance = lpInterest.award;\n        uint256 surplusAmount = nowbanance;\n        uint256 iterations = 0;\n        uint index = lpInterest.index;\n        uint sendedCount = 0;\n        uint sendCountLimit = lpInterest.sendCount;\n\n        uint ts = lpInterest.token.totalSupply();\n        while (sendedCount < sendCountLimit && iterations < shareholderCount) {\n            if (index >= shareholderCount) {\n                index = 0;\n            }\n\n            address shareholder = lpInterest.tokenHolder.at(index);\n            uint256 amount = nowbanance.mul(lpInterest.token.balanceOf(shareholder)).div(ts);\n\n            if (IERC20(usdt).balanceOf(address(this)) < amount || surplusAmount < amount) break;\n\n            if (amount >= lpInterest.minAward) {\n                surplusAmount -= amount;\n                IERC20(usdt).transfer(shareholder, amount);\n                if (shareholder == lp) {\n                    try IP22LP(lp).dividends(amount) {} catch {}\n                }\n            }\n            sendedCount ++;\n            iterations++;\n            index ++;\n        }\n        lpInterest.index = index;\n        lpInterest.award = surplusAmount;\n    }\n\n    function setEst(Interest storage est, address owner) private {\n        if (est.tokenHolder.contains(owner)) {\n            if (est.token.balanceOf(owner) == 0) {\n                try IP22IDO(ido).updateSpeed(owner, 0) {} catch {}\n                est.tokenHolder.remove(owner);\n            }\n            return;\n        }\n        if (est.token.balanceOf(owner) > 0) {\n            uint256 ts = lpInterest.token.totalSupply();\n            uint256 amount = est.token.balanceOf(owner).mul(IERC20(usdt).balanceOf(address(lpInterest.token))).mul(2).div(ts);\n            if (amount >= idoLpAccLimit.mul(10 ** uint256(IERC20(usdt).decimals()))) {\n                try IP22IDO(ido).updateSpeed(owner, idoLpAccValue) {} catch {}\n            } else {\n                try IP22IDO(ido).updateSpeed(owner, 0) {} catch {}\n            }\n            est.tokenHolder.add(owner);\n        }\n    }\n\n    function setMintingParams(uint256[] memory validHoldValues_, uint256[] memory accRates_) public onlyOwner {\n        validHoldValues = validHoldValues_;\n        accRates = accRates_;\n    }\n\n    function setStatus(address account, uint256 bw, uint256 ft, bool status) public onlyOwner {\n        if (bw == 0) {\n            if (ft == 0) {\n                ibf[account] = status;\n            } else {\n                ibt[account] = status;\n            }\n        } else {\n            if (ft == 0) {\n                iwf[account] = status;\n            } else {\n                iwt[account] = status;\n            }\n        }\n    }\n\n    function setMultiStatus(address[] memory accounts, uint256 bw, uint256 ft, bool status) public onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            setStatus(accounts[i], bw, ft, status);\n        }\n    }\n\n    function setAddr(uint256 index, address addr) public onlyOwner {\n        if (index == 0) {\n            marketAddress = addr;\n        } else if (index == 1) {\n            tokenReceiver = addr;\n        } else if (index == 2) {\n            relation = relation;\n        } else if (index == 3) {\n            ido = addr;\n        } else if (index == 4) {\n            dividends = addr;\n        } else if (index == 5) {\n            mintPool = addr;\n        } else if (index == 6) {\n            lp = addr;\n        }\n    }\n\n    function setValue(uint256 index, uint256 value) public onlyOwner {\n        if (index == 0) {\n            rewardEveryDayCoff = value;\n        } else if (index == 1) {\n            idoLpAccLimit = value;\n        } else if (index == 2) {\n            idoLpAccValue = value;\n        } else if (index == 3) {\n            rewardIdoCoff = value;\n        } else if (index == 4) {\n            startMintTime = value;\n        } else if (index == 5) {\n            mintMode = value;\n        } else if (index == 6) {\n            _buyBurnFee = value;\n            totalBuyFee = _buyBurnFee + _buyMkFee + _buyLpFee;\n        } else if (index == 7) {\n            _buyMkFee = value;\n            totalBuyFee = _buyBurnFee + _buyMkFee + _buyLpFee;\n        } else if (index == 8) {\n            _buyLpFee = value;\n            totalBuyFee = _buyBurnFee + _buyMkFee + _buyLpFee;\n        } else if (index == 9) {\n            _sellBurnFee = value;\n            totalSellFee = _sellBurnFee + _sellMkFee + _sellLpFee;\n        } else if (index == 10) {\n            _sellMkFee = value;\n            totalSellFee = _sellBurnFee + _sellMkFee + _sellLpFee;\n        } else if (index == 11) {\n            _sellLpFee = value;\n            totalSellFee = _sellBurnFee + _sellMkFee + _sellLpFee;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}