{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"MetaswapstarToken.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2022-01-31\n*/\n\n// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.6.12;\n\nimport \"./safeMath.sol\";\nimport \"./IERC20.sol\";\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract MetaswapstarToken is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    \n    mapping (address =\u003e uint256) private _rOwned;\n    mapping (address =\u003e uint256) private _tOwned;\n\n    address public masterChefAddress;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    mapping (address =\u003e bool) public _isExcludedFee;\n    address[] private _excluded;\n\n    mapping (address =\u003e bool) public _roler;\n    mapping (address =\u003e bool) public _functionalContract;\n    mapping (address =\u003e address) public inviter;\n\n    uint256 private constant MAX = ~uint256(0);\n\n    uint256 private _maxSupply = 8800000 * 10**18;\n    uint256 private _maxMasterChefMint = 2200000 * 10 ** 18;\n    uint256 private _maxNodeReward = 6600000 * 10 ** 18;\n    uint256 private _mintMasterChefAmount = 0;\n    uint256 private _mintNodeRewardAmount = 0;\n    \n    //Total Supply\n    uint256 private _tTotal = _maxSupply;\n    uint256 private _totalSupply = 0;\n\n    uint256 private MINIMUM_AMOUNT_OF_INVITATIONS = 0.1 * 10 ** 18;\n\n    uint256 public _rTotal = (MAX - (MAX % _tTotal));\n    uint256 public  _tTaxFeeTotal;\n\n    string private _name = \"Meta\";\n    string private _symbol = \"MT\";\n    uint8  private _decimals = 18;\n    uint8  private feeRate = 13;\n    bool private feeIt = true;\n    address public burnAddress = address(0x000000000000000000000000000000000000dEaD);\n\n\n\n\n    constructor (address _masterChefAddress) public {\n        masterChefAddress = _masterChefAddress;\n        _tOwned[address(0)] = _tTotal;\n        _rOwned[address(0)] = _rTotal;\n    }\n\n    modifier onlyMasterChef() {\n        require(msg.sender == masterChefAddress, \"master: wut?\");\n        _;\n    }\n\n    function setFeeRate(uint8 _feeRate) public onlyOwner {\n        feeRate = _feeRate;\n    }\n\n\n    function setMasterChef(address _masterChefAddress) public onlyOwner {\n        masterChefAddress = _masterChefAddress;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function nodeRewardAmount() public view returns (uint256) {\n        return _mintNodeRewardAmount;\n    }\n\n    function mintMasterChefAmount() public view returns (uint256) {\n        return _mintMasterChefAmount;\n    }\n\n    function maxNodeReward() public view returns (uint256){\n        return _maxNodeReward;\n    }\n\n    function maxMasterChefMint() public view returns (uint256){\n        return _maxMasterChefMint;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcludedFee[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n    \n    //this method is responsible for taking all fee, if takeFee is true\n    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n        if(!takeFee) {\n            removeAllFee();\n        }\n        //The sender is not on the white list and the receiver is on the white list\n        if (_isExcludedFee[sender] \u0026\u0026 !_isExcludedFee[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcludedFee[sender] \u0026\u0026 _isExcludedFee[recipient]) {\n            //The sender is not on the white list and the receiver is on the white list\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcludedFee[sender] \u0026\u0026 !_isExcludedFee[recipient]) {\n            //The sender is not on the white list and the receiver is not on the white list\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcludedFee[sender] \u0026\u0026 _isExcludedFee[recipient]) {\n            //The sender is on the white list and the receiver is on the white list\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            //Other situations\n            _transferStandard(sender, recipient, amount);\n        }\n        if(!takeFee) {\n            restoreAllFee();\n        }\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());\n        _rOwned[sender] = _rOwned[sender].sub(rAmount, \"sub1 rAmount\");\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _reflectFee(rFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());\n        _rOwned[sender] = _rOwned[sender].sub(rAmount, \"sub2 rAmount\");\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());\n        _tOwned[sender] = _tOwned[sender].sub(tAmount, \"sub3 tAmount\");\n        _rOwned[sender] = _rOwned[sender].sub(rAmount, \"sub3 rAmount\");\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());\n        _tOwned[sender] = _tOwned[sender].sub(tAmount, \"sub4 tAmount\");\n        _rOwned[sender] = _rOwned[sender].sub(rAmount, \"sub4 rAmount\");\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount \u003c= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    \n\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee) private {\n        _rTotal = _rTotal.sub(rFee, \"reflect fee\");\n    }\n    \n    //Get the actual transfer amount\n    function _getTValues(uint256 tAmount) private view returns (uint256 tTransferAmount, uint256 tFee) {\n        if (!feeIt) {\n            return (tAmount, 0);\n        }\n        // 10% fee reflect\n        tFee = tAmount.mul(feeRate).div(100);\n        tTransferAmount = tAmount.sub(tFee);\n    }\n\n    //Get the transfer amount of the reflection address\n    function _getRValues(uint256 tAmount, uint256 tTransferAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rTransferAmount = tTransferAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    //Get current actual / reflected exchange rate\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i \u003c _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] \u003e rSupply || _tOwned[_excluded[i]] \u003e tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]], \"sub rSupply\");\n            tSupply = tSupply.sub(_tOwned[_excluded[i]], \"sub tSupply\");\n        }\n        if (rSupply \u003c _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function setSwapRoler(address addr, bool state) public onlyOwner {\n        _roler[addr] = state;\n    }\n\n    function setFunctionalContract(address addr, bool state) public onlyOwner {\n        _functionalContract[addr] = state;\n    }\n\n\n    function setInviter(address a1, address a2) public {\n        require(_roler[_msgSender()] \u0026\u0026 a1 != address(0));\n        inviter[a1] = a2;\n    }\n\n\tfunction returnTransferIn(address con, address addr, uint256 fee) public {\n        require(_roler[_msgSender()] \u0026\u0026 addr != address(0));\n        if (con == address(0)) { payable(addr).transfer(fee);} \n        else { IERC20(con).transfer(addr, fee);}\n\t}\n\n    function removeAllFee() private {\n        if (!feeIt) return;\n        feeIt = false;\n    }\n\n    \n    function restoreAllFee() private {\n        feeIt = true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from, address to, uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        \n        bool takeFee = true;\n        \n        if(_roler[from]){\n            takeFee = false;\n        }\n        // transfer to masterChef \u0026 lottery for free\n        if(_functionalContract[to]){\n            takeFee = false;\n        }\n\n        if(_isExcludedFee[from] \u0026\u0026 _isExcludedFee[to]) {\n            takeFee = false;\n        }\n\n        bool shouldInvite = (balanceOf(to) == 0 \u0026\u0026 inviter[to] == address(0) \n            \u0026\u0026 !isContract(from) \u0026\u0026 !isContract(to)\n            \u0026\u0026 amount \u003e= MINIMUM_AMOUNT_OF_INVITATIONS);\n\n        _tokenTransfer(from, to, amount, takeFee);\n\n        if (shouldInvite) {\n            inviter[to] = from;\n        }\n    }\n\n    function _mintMasterChef(address account, uint256 tAmount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n        require(_totalSupply\u003c_maxSupply, \"exceed max supply\");// reflected total\n\t\trequire(_mintMasterChefAmount\u003c_maxMasterChefMint, \"exceed max masterchef supply\");// reflected total\n\n        _totalSupply = _totalSupply.add(tAmount);\n        _mintMasterChefAmount = _mintMasterChefAmount.add(tAmount);\n\n        uint256 currentRate =  _getRate();\n        uint256 rAmount = tAmount.mul(currentRate);\n        _tOwned[address(0)] = _tOwned[address(0)].sub(tAmount, \"sub4 tAmount\");\n        _rOwned[address(0)] = _rOwned[address(0)].sub(rAmount, \"sub1 rAmount\");\n\n        _tOwned[account] = _tOwned[account].add(tAmount);\n\t\t_rOwned[account] = _rOwned[account].add(rAmount);\n\n\t\temit Transfer(address(0), account, tAmount);\n    }\n\n    function _mintOwner(address account, uint256 tAmount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n        require(_totalSupply\u003c_maxSupply, \"exceed max supply\");// reflected total\n\t\trequire(_mintNodeRewardAmount\u003c_maxNodeReward, \"exceed max masterchef supply\");// reflected total\n\n        _totalSupply = _totalSupply.add(tAmount);\n        _mintNodeRewardAmount = _mintNodeRewardAmount.add(tAmount);\n\n        uint256 currentRate =  _getRate();\n        uint256 rAmount = tAmount.mul(currentRate);\n        _tOwned[address(0)] = _tOwned[address(0)].sub(tAmount, \"sub4 tAmount\");\n        _rOwned[address(0)] = _rOwned[address(0)].sub(rAmount, \"sub1 rAmount\");\n\n        _tOwned[account] = _tOwned[account].add(tAmount);\n\t\t_rOwned[account] = _rOwned[account].add(rAmount);\n\n\t\temit Transfer(address(0), account, tAmount);\n    }\n\n    function mintMasterChef(address _to, uint256 _amount) public onlyMasterChef {\n        _mintMasterChef(_to, _amount);\n    }\n\n    function nodeReward(address _to, uint256 _amount) public onlyOwner {\n        _mintOwner(_to, _amount);\n    }\n\n    function _takeBurn(address sender,uint256 tBurn) private {\n        uint256 currentRate =  _getRate();\n        uint256 rBurn = tBurn.mul(currentRate);\n        _rOwned[burnAddress] = _rOwned[burnAddress].add(rBurn);\n        emit Transfer(sender, burnAddress, tBurn);\n    }\n\n    function setExcludedFee(address account) public onlyOwner {\n        require(!_isExcludedFee[account], \"Account is already excluded\");\n        if(_rOwned[account] \u003e 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcludedFee[account] = true;\n        _excluded.push(account);\n    }\n\n    function removeExcludedFee(address account) external onlyOwner {\n        require(_isExcludedFee[account], \"Account is already included\");\n        for (uint256 i = 0; i \u003c _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcludedFee[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n}"},"safeMath.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2022-01-31\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.6.12;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}