{{
  "language": "Solidity",
  "sources": {
    "contracts/ATH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IStaking {\n    function bonusUsdt(uint256 _amount) external;\n}\n\ncontract ATHENA {\n    string public name = \"ATHENA\";\n    string public symbol = \"ATH\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 0;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public owner;\n    address public lpStaking;\n    address private burnAddress = 0x000000000000000000000000000000000000dEaD; //燃烧地址\n    address public routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E; //uniswapRouter\n    address public usdtAddress = 0x55d398326f99059fF775485246999027B3197955; //usdtAddress\n    address public lpPairAddress; //lpPairAddress\n    bool public swapTokenToMarketEnabled = true;\n    uint256 public swapTokenOverflowNum = 500 * 10**decimals; //超过多少个token可以转换成市场 500\n\n    uint256 public buyFee = 30; // 30/1000\n    uint256 public buyInviteFee = 10; // 10/1000\n    uint256 public burnFee = 10; // 10/1000\n    uint256 public operateFee = 10; // 10/1000\n    address public operateAddress = 0xDb075E924a3845Ce3DBcD669fe565cDA1c17d325; //1%运营\n\n    uint256 public sellFee = 60; // 60/1000\n    uint256 public sellInviteFee = 10; // 10/1000\n    uint256 public lpFee = 20; // 20/1000\n    uint256 public marketFee = 30; // 10/1000 //奖励市场钱包，分红触发卖成USDT\n\n    bool public isBuy = false; // 买入开关\n\n    mapping(address => bool) public whitelist; // 白名单\n    mapping(address => bool) public blacklist; // 黑名单\n    mapping(address => bool) public pairlist; // 流动池\n\n    mapping(address => address) public inviter; // 邀请人\n    mapping(address => uint256) public inviteCount; // 邀请人数量\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed holder,\n        address indexed spender,\n        uint256 value\n    );\n    event BindInviter(address indexed _user, address indexed _inviter);\n\n    constructor(address dao_, address _lp_staking) {\n        owner = msg.sender;\n        lpStaking = _lp_staking;\n\n        whitelist[owner] = true;\n        whitelist[dao_] = true;\n        whitelist[lpStaking] = true;\n        whitelist[address(this)] = true;\n\n        uint256 _totalSupply = 10000000 * 10**decimals;\n        uint256 lpSupply = 3360000 * 10**decimals;\n        _mint(dao_, _totalSupply - lpSupply);\n        _mint(lpStaking, lpSupply);\n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\n        lpPairAddress = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), usdtAddress);\n        pairlist[lpPairAddress] = true;\n\n        allowance[address(this)][routerAddress] = ~uint256(0);\n        safeApprove(usdtAddress, lpStaking, ~uint256(0));\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setOwner(address newOwner) public onlyOwner {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n\n    function setOperateAddress(address _operateAddress) public onlyOwner {\n        operateAddress = _operateAddress;\n    }\n\n    function setLpStaking(address _lp_staking) public onlyOwner {\n        lpStaking = _lp_staking;\n    }\n\n    function setBurnAddress(address _burnAddress) public onlyOwner {\n        burnAddress = _burnAddress;\n    }\n\n    function setLpPairAddress(address _lpPairAddress) public onlyOwner {\n        lpPairAddress = _lpPairAddress;\n    }\n\n    function setUsdtAddress(address _usdtAddress) public onlyOwner {\n        usdtAddress = _usdtAddress;\n    }\n\n    function setSwapTokenToMarketEnabled(bool _swapTokenToMarketEnabled)\n        public\n        onlyOwner\n    {\n        swapTokenToMarketEnabled = _swapTokenToMarketEnabled;\n    }\n\n    function setSwapTokenOverflowNum(uint256 _swapTokenOverflowNum)\n        public\n        onlyOwner\n    {\n        swapTokenOverflowNum = _swapTokenOverflowNum;\n    }\n\n    function setBuyFee(\n        uint256 _inviteFee,\n        uint256 _burnFee,\n        uint256 _operateFee\n    ) public onlyOwner {\n        buyFee = _inviteFee + _burnFee + _operateFee;\n        require(buyFee <= 1000, \"fee rate max error\");\n        buyInviteFee = _inviteFee;\n        burnFee = _burnFee;\n        operateFee = _operateFee;\n    }\n\n    function setSellFee(\n        uint256 _inviteFee,\n        uint256 _lpFee,\n        uint256 _marketFee\n    ) public onlyOwner {\n        sellFee = _inviteFee + _lpFee + _marketFee;\n        require(sellFee <= 1000, \"fee rate max error\");\n        sellInviteFee = _inviteFee;\n        lpFee = _lpFee;\n        marketFee = _marketFee;\n    }\n\n    function setWhitelist(address[] memory addrlist, bool value)\n        public\n        onlyOwner\n    {\n        require(addrlist.length > 0, \"lsit empty error\");\n        for (uint256 i = 0; i < addrlist.length; i++) {\n            whitelist[addrlist[i]] = value;\n        }\n    }\n\n    function setBlacklist(address[] memory addrlist, bool value)\n        public\n        onlyOwner\n    {\n        require(addrlist.length > 0, \"lsit empty error\");\n        for (uint256 i = 0; i < addrlist.length; i++) {\n            blacklist[addrlist[i]] = value;\n        }\n    }\n\n    function setIsBuy(bool _isBuy) public onlyOwner {\n        isBuy = _isBuy;\n    }\n\n    function setPairlist(address addr, bool value) public onlyOwner {\n        pairlist[addr] = value;\n    }\n\n    // 绑定邀请人\n    function setInviter(address inviter_) external virtual returns (bool) {\n        require(inviter[msg.sender] == address(0), \"has been invited\");\n        require(msg.sender != inviter_, \"don't invite yourself\");\n\n        require(inviter[inviter_] != msg.sender, \"inviter invited error\");\n\n        inviter[msg.sender] = inviter_;\n        inviteCount[inviter_] += 1;\n        emit BindInviter(msg.sender, inviter_);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 currentAllowance = allowance[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = allowance[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(!blacklist[sender], \"ERC20: transfer from blacklisted account\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = balanceOf[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            balanceOf[sender] = senderBalance - amount;\n        }\n        balanceOf[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        totalSupply += amount;\n        balanceOf[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[holder][spender] = amount;\n        emit Approval(holder, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (amount == 0 || whitelist[to] || whitelist[from]) {\n            return;\n        }\n        if (pairlist[from] && buyFee > 0) {\n            require(isBuy, \"ERC20: buy error\");\n            takeFee(to, burnAddress, amount, burnFee);\n            takeFee(to, operateAddress, amount, operateFee);\n\n            address _invite = inviter[to];\n            if (_invite != address(0)) {\n                takeFee(to, _invite, amount, buyInviteFee);\n            } else {\n                takeFee(to, operateAddress, amount, buyInviteFee);\n            }\n        } else if (pairlist[to] && sellFee > 0) {\n            takeFee(to, lpPairAddress, amount, lpFee);\n            address _invite = inviter[from];\n            if (_invite != address(0)) {\n                takeFee(to, _invite, amount, sellInviteFee);\n            } else {\n                takeFee(to, operateAddress, amount, sellInviteFee);\n            }\n\n            takeFee(to, address(this), amount, marketFee);\n        } else {\n            swapTokensForToken();\n        }\n    }\n\n    function takeFee(\n        address _spender,\n        address _to,\n        uint256 amount,\n        uint256 _feeRate\n    ) private {\n        if (_feeRate > 0) {\n            uint256 _fee = (amount * _feeRate) / 1000;\n            balanceOf[_to] += _fee;\n            balanceOf[_spender] -= _fee;\n            emit Transfer(_spender, _to, _fee);\n        }\n    }\n\n    function swapTokensForToken() public {\n        uint256 tokenAmount = balanceOf[address(this)];\n        if (swapTokenToMarketEnabled && tokenAmount >= swapTokenOverflowNum) {\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = usdtAddress;\n\n            uint256 balanceBefore = IERC20(usdtAddress).balanceOf(lpStaking); //兼容有手续费的代币\n\n            IUniswapV2Router02(routerAddress)\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                    tokenAmount,\n                    0, // accept any amount of ETH\n                    path,\n                    lpStaking,\n                    block.timestamp\n                );\n\n            uint256 balanceAdd = IERC20(usdtAddress).balanceOf(lpStaking) -\n                balanceBefore; //兼容有手续费的代币\n\n            IStaking(lpStaking).bonusUsdt(balanceAdd);\n        }\n    }\n\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function approveUinswap() public onlyOwner {\n        allowance[address(this)][routerAddress] = ~uint256(0);\n    }\n\n    function approveToken(address token, address to) public onlyOwner {\n        safeApprove(token, to, ~uint256(0));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}