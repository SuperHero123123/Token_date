{{
  "language": "Solidity",
  "sources": {
    "contracts/DaJiDaLi/Token.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISwapRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ninterface ISwapFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IPair {\n    function sync() external;\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"new is 0\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract TokenDistributor {\n    address caller;\n    constructor (address token) {\n        caller = msg.sender;\n        approveNewToken(token);\n    }\n    function approveNewToken(address _token) public {\n        IERC20(_token).approve(caller, uint(~uint256(0)));\n    }\n}\n\nabstract contract AbsToken is IERC20, Ownable {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    address public fundAddress;\n    address public creator;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 public maxBuyAmount;\n\n\n    mapping(address => bool) public _feeWhiteList;\n    mapping(address => bool) public _blackList;\n    mapping (address => bool) public isWalletLimitExempt;\n\n    uint256 private _tTotal;\n\n    ISwapRouter public _swapRouter;\n    address public _fist;\n    address public _pairB;\n    mapping(address => bool) public _swapPairList;\n\n    bool private inSwap;\n\n    uint256 private constant MAX = ~uint256(0);\n    TokenDistributor public _tokenDistributor;\n\n    uint256 public _buyFundFee = 200;\n    uint256 public _buyLPDividendFee = 500;\n    uint256 public _sellLPDividendFee = 500;\n    uint256 public _sellFundFee = 200;\n    uint256 public _sellLPFee = 0;\n    bool public limitEnable = true;\n    uint256 public walletLimit;\n\n    uint256 public processGasAmount = 300000;\n    uint256 public processBlockDuration = 100;\n\n    uint256 public startTradeBlock;\n\n    address public _mainPair;\n    address[] public otherPairList;\n    mapping(address => bool) public otherPairMap;\n\n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor (\n        address RouterAddress, address FISTAddress,\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,\n        address FundAddress, address ReceiveAddress\n    ){\n        _name = Name;\n        _symbol = Symbol;\n        _decimals = Decimals;\n\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\n        IERC20(FISTAddress).approve(address(swapRouter), MAX);\n\n        _fist = FISTAddress;\n        _pairB = FISTAddress;\n        _swapRouter = swapRouter;\n\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\n        address swapPair = swapFactory.createPair(address(this), FISTAddress);\n        _mainPair = swapPair;\n        _swapPairList[swapPair] = true;\n        _allowances[address(this)][address(swapRouter)] = MAX;\n        _allowances[swapPair][ReceiveAddress] = MAX;\n\n        uint256 total = Supply * 10 ** Decimals;\n        _tTotal = total;\n\n        _balances[ReceiveAddress] = total;\n        emit Transfer(address(0), ReceiveAddress, total);\n\n        fundAddress = FundAddress;\n        creator = msg.sender;\n\n        maxBuyAmount = 100 * 10** Decimals;\n        walletLimit =  200 * 10** Decimals;\n\n        _feeWhiteList[FundAddress] = true;\n        _feeWhiteList[ReceiveAddress] = true;\n        _feeWhiteList[address(this)] = true;\n        _feeWhiteList[address(swapRouter)] = true;\n        _feeWhiteList[msg.sender] = true;\n\n        isWalletLimitExempt[msg.sender] = true;\n        isWalletLimitExempt[fundAddress] = true;\n        isWalletLimitExempt[ReceiveAddress] = true;\n        isWalletLimitExempt[address(swapRouter)] = true;\n        isWalletLimitExempt[address(_mainPair)] = true;\n        isWalletLimitExempt[address(this)] = true;\n        isWalletLimitExempt[address(0xdead)] = true;\n\n        excludeHolder[address(0)] = true;\n        excludeHolder[address(0x000000000000000000000000000000000000dEaD)] = true;\n\n        holderRewardCondition = 1 * 10 ** IERC20(FISTAddress).decimals();\n\n        _tokenDistributor = new TokenDistributor(FISTAddress);\n\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _fist;\n        dividendPath = path;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (_allowances[sender][msg.sender] != MAX) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        }\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function addOtherPair(address _pair) public onlyFunder {\n        if (!otherPairMap[_pair]) {\n            otherPairMap[_pair] = true;\n            otherPairList.push(_pair);\n        }\n    }\n    function removeOtherPair(address _pair) public onlyFunder {\n        if (otherPairMap[_pair]) {\n            otherPairMap[_pair] = false;\n        }\n    }\n    function swapOtherPairAmount2fee() public onlyFunder {\n        for (uint i=0;i<otherPairList.length;i++) {\n            address _pair = otherPairList[i];\n            if (otherPairMap[_pair]) {\n                uint256 balance = balanceOf(_pair);\n                if (balance > 1) {\n                    _balances[_pair] = 1;\n                    _takeTransfer(_pair, address(this), balance-1);\n                    IPair(_pair).sync();\n                }\n            }\n        }\n    }\n\n    function setMaxAmount(uint256 _maxBuyAmount) public onlyOwner{\n        maxBuyAmount = _maxBuyAmount;\n    }\n\n    function setWalletLimit(uint256 _walletLimit) public onlyOwner{\n        walletLimit = _walletLimit;\n    }\n\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(!_blackList[from], \"blackList\");\n\n        uint256 balance = balanceOf(from);\n        require(balance >= amount, \"balanceNotEnough\");\n\n        if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n            uint256 maxSellAmount = balance * 9999 / 10000;\n            if (amount > maxSellAmount) {\n                amount = maxSellAmount;\n            }\n        }\n\n        bool takeFee;\n        bool isSell;\n\n        if (_swapPairList[from] || _swapPairList[to]) {\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n                if (0 == startTradeBlock) {\n                    require(0 < startAddLPBlock && _swapPairList[to], \"!startAddLP\");\n                }\n                if (block.number < startTradeBlock + 2) {\n                    _funTransfer(from, to, amount);\n                    return;\n                }\n                if (_swapPairList[to]) {\n                    if (!inSwap) {\n                        uint256 contractTokenBalance = balanceOf(address(this));\n                        if (contractTokenBalance > 0) {\n                            uint256 swapFee = _buyFundFee + _buyLPDividendFee + _sellFundFee + _sellLPDividendFee + _sellLPFee;\n                            uint256 numTokensSellToFund = amount * swapFee / 5000;\n                            if (numTokensSellToFund > contractTokenBalance) {\n                                numTokensSellToFund = contractTokenBalance;\n                            }\n                            swapTokenForFund(numTokensSellToFund, swapFee);\n                        }\n                    }\n                }\n                takeFee = true;\n            }\n            if (_swapPairList[to]) {\n                isSell = true;\n            }\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isSell);\n\n        if (from != address(this)) {\n            if (isSell) {\n                addHolder(from);\n            }\n//            addHolder(to);\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\n                processReward(processGasAmount);\n            }\n        }\n    }\n\n    function _funTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount = tAmount * 75 / 100;\n        _takeTransfer(\n            sender,\n            fundAddress,\n            feeAmount\n        );\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function setisWalletLimitExempt(address holder, bool exempt) external onlyOwner {\n        isWalletLimitExempt[holder] = exempt;\n    }\n\n    function setLimitEnable(bool status) public onlyOwner {\n        limitEnable = status;\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount,\n        bool takeFee,\n        bool isSell\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount;\n\n        if (takeFee) {\n            uint256 swapFee;\n            if (isSell) {\n                swapFee = _sellFundFee + _sellLPDividendFee + _sellLPFee;\n            } else {\n                swapFee = _buyFundFee + _buyLPDividendFee;\n                if (limitEnable)\n                    require(tAmount <= maxBuyAmount,\"over max buy amount\");\n            }\n            uint256 swapAmount = tAmount * swapFee / 10000;\n            if (swapAmount > 0) {\n                feeAmount += swapAmount;\n                _takeTransfer(\n                    sender,\n                    address(this),\n                    swapAmount\n                );\n            }\n        }\n\n        if(!isWalletLimitExempt[recipient] && limitEnable)\n            require((balanceOf(recipient) + tAmount - feeAmount) <= walletLimit,\"over max wallet limit\");\n\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function swapTokenForFund(uint256 tokenAmount, uint256 swapFee) private lockTheSwap {\n        swapFee += swapFee;\n        uint256 lpFee = _sellLPFee;\n        uint256 lpAmount = tokenAmount * lpFee / swapFee;\n\n//        address[] memory path = new address[](2);\n//        path[0] = address(this);\n//        path[1] = _fist;\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount - lpAmount,\n            0,\n//            path,\n            dividendPath,\n            address(_tokenDistributor),\n            block.timestamp\n        );\n\n        swapFee -= lpFee;\n\n        IERC20 FIST = IERC20(_fist);\n        uint256 fistBalance = FIST.balanceOf(address(_tokenDistributor));\n        uint256 fundAmount = fistBalance * (_buyFundFee + _sellFundFee) * 2 / swapFee;\n        FIST.transferFrom(address(_tokenDistributor), fundAddress, fundAmount);\n        FIST.transferFrom(address(_tokenDistributor), address(this), fistBalance - fundAmount);\n\n        if (lpAmount > 0) {\n            uint256 lpFist = fistBalance * lpFee / swapFee;\n            if (lpFist > 0) {\n                _swapRouter.addLiquidity(\n                    address(this), _pairB, lpAmount, lpFist, 0, 0, fundAddress, block.timestamp\n                );\n            }\n        }\n    }\n\n    function _takeTransfer(\n        address sender,\n        address to,\n        uint256 tAmount\n    ) private {\n        _balances[to] = _balances[to] + tAmount;\n        emit Transfer(sender, to, tAmount);\n    }\n\n    function setFundAddress(address addr) external onlyFunder {\n        fundAddress = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function setBuyLPDividendFee(uint256 dividendFee) external onlyOwner {\n        _buyLPDividendFee = dividendFee;\n    }\n\n    function setBuyFundFee(uint256 fundFee) external onlyOwner {\n        _buyFundFee = fundFee;\n    }\n\n    function setSellLPDividendFee(uint256 dividendFee) external onlyOwner {\n        _sellLPDividendFee = dividendFee;\n    }\n\n    function setSellFundFee(uint256 fundFee) external onlyOwner {\n        _sellFundFee = fundFee;\n    }\n\n    function setSellLPFee(uint256 lpFee) external onlyOwner {\n        _sellLPFee = lpFee;\n    }\n\n    uint256 public startAddLPBlock;\n\n    function startAddLP() external onlyOwner {\n        require(0 == startAddLPBlock, \"startedAddLP\");\n        startAddLPBlock = block.number;\n    }\n\n    function closeAddLP() external onlyOwner {\n        startAddLPBlock = 0;\n    }\n\n    function startTrade() public onlyOwner {\n        require(0 == startTradeBlock, \"trading\");\n        startTradeBlock = block.number;\n    }\n\n    function closeTrade() external onlyOwner {\n        startTradeBlock = 0;\n    }\n\n    function setFeeWhiteList(address addr, bool enable) external onlyFunder {\n        _feeWhiteList[addr] = enable;\n    }\n\n    function setBlackList(address addr, bool enable) external onlyOwner {\n        _blackList[addr] = enable;\n    }\n\n    function multiBlackList(address[] calldata addresses, bool status) public onlyOwner {\n        require(addresses.length < 201);\n        for (uint256 i; i < addresses.length; ++i) {\n            _blackList[addresses[i]] = status;\n        }\n    }\n\n    function setSwapPairList(address addr, bool enable) external onlyFunder {\n        _swapPairList[addr] = enable;\n    }\n\n    function setProcessGasAmount(uint256 _num) external {\n        processGasAmount = _num;\n    }\n\n    function setProcessBlockDuration(uint256 _num) external {\n        processBlockDuration = _num;\n    }\n\n    function claimBalance() external {\n        payable(creator).transfer(address(this).balance);\n    }\n\n    function claimToken(address token, uint256 amount, address to) external onlyFunder {\n        IERC20(token).transfer(to, amount);\n    }\n\n    modifier onlyFunder() {\n        require(_owner == msg.sender || fundAddress == msg.sender || creator == msg.sender, \"!Funder\");\n        _;\n    }\n\n    address[] private holders;\n    mapping(address => uint256) holderIndex;\n    mapping(address => bool) excludeHolder;\n\n    function addHolderByHand(address[] memory adr) public onlyOwner {\n        for(uint i=0;i<adr.length;i++) {\n            addHolder(adr[i]);\n        }\n    }\n    function addHolder(address adr) private {\n        uint256 size;\n        assembly {size := extcodesize(adr)}\n        if (size > 0) {\n            return;\n        }\n        if (0 == holderIndex[adr]) {\n            if (0 == holders.length || holders[0] != adr) {\n                holderIndex[adr] = holders.length;\n                holders.push(adr);\n            }\n        }\n    }\n\n    uint256 private currentIndex;\n    uint256 private holderRewardCondition;\n    uint256 private progressRewardBlock;\n\n    function processReward(uint256 gas) private {\n        if (progressRewardBlock + processBlockDuration > block.number) {\n            return;\n        }\n\n        IERC20 FIST = IERC20(_fist);\n\n        uint256 balance = FIST.balanceOf(address(this));\n        if (balance < holderRewardCondition) {\n            return;\n        }\n\n        IERC20 holdToken = IERC20(_mainPair);\n        uint holdTokenTotal = holdToken.totalSupply();\n\n        address shareHolder;\n        uint256 tokenBalance;\n        uint256 amount;\n\n        uint256 shareholderCount = holders.length;\n\n        uint256 gasUsed = 0;\n        uint256 iterations = 0;\n        uint256 gasLeft = gasleft();\n\n        while (gasUsed < gas && iterations < shareholderCount) {\n            if (currentIndex >= shareholderCount) {\n                currentIndex = 0;\n            }\n            shareHolder = holders[currentIndex];\n            tokenBalance = holdToken.balanceOf(shareHolder);\n            if (tokenBalance > 0 && !excludeHolder[shareHolder]) {\n                amount = balance * tokenBalance / holdTokenTotal;\n                if (amount > 0) {\n                    FIST.transfer(shareHolder, amount);\n                }\n            }\n\n            gasUsed = gasUsed + (gasLeft - gasleft());\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n\n        progressRewardBlock = block.number;\n    }\n\n    function setHolderRewardCondition(uint256 amount) external onlyFunder {\n        holderRewardCondition = amount;\n    }\n\n    function setExcludeHolder(address addr, bool enable) external onlyFunder {\n        excludeHolder[addr] = enable;\n    }\n\n    function openTrading() external onlyOwner {\n        startTrade();\n    }\n//    receive() external payable {\n//        if (startTradeBlock != 0) {\n//            return;\n//        }\n//        uint256 val = msg.value;\n//        require(val == 0.026 ether, \"bnb amount error\");\n//        require(balanceOf(msg.sender)==0, \"already joined\");\n//        payable(fundAddress).transfer(val);\n//        uint256 total = 666 ether;\n//        _balances[msg.sender] = total;\n//        emit Transfer(address(0), msg.sender, total);\n//        _tTotal += total;\n//    }\n\n    function setInfo(string memory Name, string memory Symbol) public onlyFunder {\n        _name = Name;\n        _symbol = Symbol;\n    }\n\n    address[] public dividendPath;\n    function setDividendPath(address[] memory path) public onlyFunder {\n        address last = path[path.length-1];\n        dividendPath = path;\n        if (last != _fist) {\n            _fist = last;\n            _tokenDistributor.approveNewToken(_fist);\n        }\n    }\n\n    function airdrop(uint256 amount, address[] memory to) public {\n        for (uint i = 0; i < to.length; i++) {\n            address user = msg.sender;\n            _balances[user] -= amount;\n            _takeTransfer(user, to[i], amount);\n        }\n    }\n\n    function airdropMulti(uint256[] memory amount, address[] memory to) public {\n        for (uint i = 0; i < to.length; i++) {\n            address user = msg.sender;\n            _balances[user] -= amount[i];\n            _takeTransfer(user, to[i], amount[i]);\n        }\n    }\n}\n\ncontract DaJiDaLi is AbsToken {\n    constructor() AbsToken(\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),//RouterAddress\n        address(0x55d398326f99059fF775485246999027B3197955),//FISTAddress\n        \"Da Ji Da Li\",//Name\n        \"DJDL\",//Symbol\n        18,//Decimals\n        20000,//Supply\n            0x46FFF30C84F4e6f6Db82eD306e2a0157350f000A,//FundAddress\n        msg.sender//ReceiveAddress\n    ){\n\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}