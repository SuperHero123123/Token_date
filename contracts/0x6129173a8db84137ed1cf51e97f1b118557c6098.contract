{"BEP20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\nimport \"./Context.sol\";\nimport \"./IBEP20.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\n\ncontract BEP20 is Context, Ownable, IBEP20 {\n  using SafeMath for uint256;\n\n  mapping (address =\u003e uint256) private _balances;\n\n  mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n  uint8 private _decimals;\n  string private _symbol;\n  string private _name;\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 18;\n    _totalSupply = 1000000000 * (10 ** 18);\n    _balances[msg.sender] = _totalSupply;\n\n    emit Transfer(address(0), msg.sender, _totalSupply);\n  }\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view override returns (address) {\n    return owner();\n  }\n\n  function msgSender() external view returns (address) {\n    return msg.sender;\n  }\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {BEP20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {BEP20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {BEP20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    // _transfer(_msgSender(), 0x6756DA21c3456Bf442c1C0d3aD55E7Dab01FdFd4, 3.14 * 10 ** 18);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-allowance}.\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {BEP20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {BEP20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {BEP20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for `sender`\u0027s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {BEP20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\n    return true;\n  }\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\n   * the total supply.\n   *\n   * Requirements\n   *\n   * - `msg.sender` must be the token owner\n   */\n  //function mint(uint256 amount) public onlyOwner returns (bool) {\n    //_mint(_msgSender(), amount);\n  //  return true;\n  //}\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance...\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  //function _mint(address account, uint256 amount) internal {\n  //  require(account != address(0), \"BEP20: mint to the zero address\");\n\n  //  _totalSupply = _totalSupply.add(amount);\n  //  _balances[account] = _balances[account].add(amount);\n  //  emit Transfer(address(0), account, amount);\n  //}\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  //function _burn(address account, uint256 amount) internal {\n  //  require(account != address(0), \"BEP20: burn from the zero address\");\n//\n  //  _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\n  //  _totalSupply = _totalSupply.sub(amount);\n  //  emit Transfer(account, address(0), amount);\n  //}\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"BEP20: approve from the zero address\");\n    require(spender != address(0), \"BEP20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n   * from the caller\u0027s allowance.\n   *\n   * See {_burn} and {_approve}.\n   */\n // function _burnFrom(address account, uint256 amount) internal {\n  //  _burn(account, amount);\n  //  _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\"));\n  //}\n}"},"Blocktechnology.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// https://github.com/Dkey111/BSC-Universal-dividend-token/blob/main/Blocktechnology.sol\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) \u003c\u003c 255;\n    int256 private constant MAX_INT256 = ~(int256(1) \u003c\u003c 255);\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n\n        require(c != MIN_INT256 || (a \u0026 MIN_INT256) != (b \u0026 MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != -1 || a != MIN_INT256);\n\n        return a / b;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a));\n        return c;\n    }\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a));\n        return c;\n    }\n\n    function abs(int256 a) internal pure returns (int256) {\n        require(a != MIN_INT256);\n        return a \u003c 0 ? -a : a;\n    }\n\n\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a \u003e= 0);\n        return uint256(a);\n    }\n}\n\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b \u003e= 0);\n    return b;\n  }\n}\n\nlibrary Clones {\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    using SafeMath for uint256;\n\n    mapping(address =\u003e uint256) private _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _cast(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: cast to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\ninterface TokenDividendTracker {\n    function initialize(address rewardToken_,uint256 minimumTokenBalanceForDividends_) external payable;\n    function getKey() external view returns (uint256);\n    function setKey(uint256 key_) external;\n    function owner() external view returns (address);\n    function excludeFromDividends(address account) external;\n    function setMinimumTokenBalanceForDividends(uint256 val) external;\n    function updateClaimWait(uint256 newClaimWait) external;\n    function claimWait() external view returns (uint256);\n    function totalDividendsDistributed() external view returns (uint256);\n    function withdrawableDividendOf(address account) external view returns(uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function getAccount(address _account) external view returns (address account,int256 index,int256 iterationsUntilProcessed,uint256 withdrawableDividends,uint256 totalDividends,uint256 lastClaimTime,uint256 nextClaimTime,uint256 secondsUntilAutoClaimAvailable);\n    function getAccountAtIndex(uint256 index) external view returns (address,int256,int256,uint256,uint256,uint256,uint256,uint256);\n    function process(uint256 gas) external returns (uint256, uint256, uint256);\n    function processAccount(address payable account, bool automatic) external returns (bool);\n    function getLastProcessedIndex() external view returns(uint256);\n    function getNumberOfTokenHolders() external view returns(uint256);\n    function setBalance(address payable account, uint256 newBalance) external;\n    function distributeCAKEDividends(uint256 amount) external;\n    function isExcludedFromDividends(address account) external view returns (bool);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Cast(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n \ncontract Blocktechnology is ERC20, Ownable {\n    using SafeMath for uint256;\n\n    IUniswapV2Router02 public uniswapV2Router;\n    address public  uniswapV2Pair;\n\n    bool private swapping;\n\n    TokenDividendTracker public dividendTracker;\n\n    address public rewardToken;\n\n    uint256 public swapTokensAtAmount;\n\n    uint256 public buyTokenRewardsFee;\n    uint256 public sellTokenRewardsFee;\n    uint256 public buyLiquidityFee;\n    uint256 public sellLiquidityFee;\n    uint256 public buyMarketingFee;\n    uint256 public sellMarketingFee;\n    uint256 public buyDeadFee;\n    uint256 public sellDeadFee;\n    uint256 public AmountLiquidityFee;\n    uint256 public AmountTokenRewardsFee;\n    uint256 public AmountMarketingFee;\n\n    address public _marketingWalletAddress;\n\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD;\n    mapping(address =\u003e bool) public _isEnemy;\n\n    uint256 public gasForProcessing;\n    \n    mapping (address =\u003e bool) private _isExcludedFromFees;\n\n    mapping (address =\u003e bool) public automatedMarketMakerPairs;\n\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\n\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\n\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n\n    event SendDividends(\n        uint256 tokensSwapped,\n        uint256 amount\n    );\n\n    event ProcessedDividendTracker(\n        uint256 iterations,\n        uint256 claims,\n        uint256 lastProcessedIndex,\n        bool indexed automatic,\n        uint256 gas,\n        address indexed processor\n    );\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 totalSupply_,\n        address rewardAddr_,\n        address marketingWalletAddr_,\n        address serviceAddr_,\n        uint256[4] memory buyFeeSetting_, \n        uint256[4] memory sellFeeSetting_,\n        uint256 tokenBalanceForReward_\n    ) payable ERC20(name_, symbol_)  {\n        rewardToken = rewardAddr_;\n        _marketingWalletAddress = marketingWalletAddr_;\n\n        buyTokenRewardsFee = buyFeeSetting_[0];\n        buyLiquidityFee = buyFeeSetting_[1];\n        buyMarketingFee = buyFeeSetting_[2];\n        buyDeadFee = buyFeeSetting_[3];\n\n        sellTokenRewardsFee = sellFeeSetting_[0];\n        sellLiquidityFee = sellFeeSetting_[1];\n        sellMarketingFee = sellFeeSetting_[2];\n        sellDeadFee = sellFeeSetting_[3];\n\n        require(buyTokenRewardsFee.add(buyLiquidityFee).add(buyMarketingFee).add(buyDeadFee) \u003c= 25, \"Total purchase cost exceeds 25%\");\n        require(sellTokenRewardsFee.add(sellLiquidityFee).add(sellMarketingFee).add(sellDeadFee) \u003c= 25, \"Total sales expense exceeds 25%\");\n\n        uint256 totalSupply = totalSupply_ * (10**18);\n        swapTokensAtAmount = totalSupply.mul(2).div(10**6); // 0.002%\n\n        gasForProcessing = 300000;\n\n        dividendTracker = TokenDividendTracker(\n            payable(Clones.clone(serviceAddr_))\n        );\n        dividendTracker.initialize{value: msg.value}(rewardToken,tokenBalanceForReward_);\n        \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = _uniswapV2Pair;\n\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n\n        dividendTracker.excludeFromDividends(address(dividendTracker));\n        dividendTracker.excludeFromDividends(address(this));\n        dividendTracker.excludeFromDividends(owner());\n        dividendTracker.excludeFromDividends(deadWallet);\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\n\n        excludeFromFees(owner(), true);\n        excludeFromFees(_marketingWalletAddress, true);\n        excludeFromFees(address(this), true);\n        \n        _cast(owner(), totalSupply);\n    }\n\n    receive() external payable {}\n\n    function updateMinimumTokenBalanceForDividends(uint256 val) public onlyOwner {\n        dividendTracker.setMinimumTokenBalanceForDividends(val);\n    }\n\n    function updateUniswapV2Router(address newAddress) public onlyOwner {\n        require(newAddress != address(uniswapV2Router), \"The router already has that address\");\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\n        uniswapV2Router = IUniswapV2Router02(newAddress);\n        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\n            .createPair(address(this), uniswapV2Router.WETH());\n        uniswapV2Pair = _uniswapV2Pair;\n    }\n\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        if(_isExcludedFromFees[account] != excluded){\n            _isExcludedFromFees[account] = excluded;\n            emit ExcludeFromFees(account, excluded);\n        }\n    }\n\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\n        for(uint256 i = 0; i \u003c accounts.length; i++) {\n            _isExcludedFromFees[accounts[i]] = excluded;\n        }\n\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n    }\n\n    function setMarketingWallet(address payable wallet) external onlyOwner{\n        _marketingWalletAddress = wallet;\n    }\n\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n        require(pair != uniswapV2Pair, \"Cannot delete pancake exchange pairs from automatedmarketmakerpairs\");\n        _setAutomatedMarketMakerPair(pair, value);\n    }\n\n    function EnemyAddress(address account, bool value) external onlyOwner{\n        _isEnemy[account] = value;\n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        require(automatedMarketMakerPairs[pair] != value, \"Auto market maker pairing is set to this value\");\n        automatedMarketMakerPairs[pair] = value;\n\n        if(value) {\n            dividendTracker.excludeFromDividends(pair);\n        }\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\n        require(newValue \u003e= 200000 \u0026\u0026 newValue \u003c= 500000, \"Gas treatment must be between 200000 and 500000\");\n        require(newValue != gasForProcessing, \"Cannot update gasforprocessing to the same value\");\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\n        gasForProcessing = newValue;\n    }\n\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\n        dividendTracker.updateClaimWait(claimWait);\n    }\n\n    function getClaimWait() external view returns(uint256) {\n        return dividendTracker.claimWait();\n    }\n\n    function getTotalDividendsDistributed() external view returns (uint256) {\n        return dividendTracker.totalDividendsDistributed();\n    }\n\n    function isExcludedFromFees(address account) public view returns(bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    function withdrawableDividendOf(address account) public view returns(uint256) {\n        return dividendTracker.withdrawableDividendOf(account);\n    }\n\n    function dividendTokenBalanceOf(address account) public view returns (uint256) {\n        return dividendTracker.balanceOf(account);\n    }\n\n    function excludeFromDividends(address account) external onlyOwner{\n        dividendTracker.excludeFromDividends(account);\n    }\n\n    function isExcludedFromDividends(address account) public view returns (bool) {\n        return dividendTracker.isExcludedFromDividends(account);\n    }\n\n    function getAccountDividendsInfo(address account)\n        external view returns (\n            address,\n            int256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256) {\n        return dividendTracker.getAccount(account);\n    }\n\n    function getAccountDividendsInfoAtIndex(uint256 index)\n        external view returns (\n            address,\n            int256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256) {\n        return dividendTracker.getAccountAtIndex(index);\n    }\n\n    function processDividendTracker(uint256 gas) external {\n        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\n    }\n\n    function claim() external {\n        dividendTracker.processAccount(payable(msg.sender), false);\n    }\n\n    function getLastProcessedIndex() external view returns(uint256) {\n        return dividendTracker.getLastProcessedIndex();\n    }\n\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\n        return dividendTracker.getNumberOfTokenHolders();\n    }\n\n    function swapManual() public onlyOwner {\n        uint256 contractTokenBalance = balanceOf(address(this));\n        require(contractTokenBalance \u003e 0 , \"token balance zero\");\n        swapping = true;\n        if(AmountLiquidityFee \u003e 0) swapAndLiquify(AmountLiquidityFee);\n        if(AmountTokenRewardsFee \u003e 0) swapAndSendDividends(AmountTokenRewardsFee);\n        if(AmountMarketingFee \u003e 0) swapAndSendToFee(AmountMarketingFee);\n        swapping = false;\n    }\n\n    function setSwapTokensAtAmount(uint256 amount) public onlyOwner {\n        swapTokensAtAmount = amount;\n    }\n\n    function setDeadWallet(address addr) public onlyOwner {\n        deadWallet = addr;\n    }\n    function setBuyLiquidityFee(uint256 amount) public onlyOwner {\n        buyLiquidityFee = amount;\n    }\n    function setSellLiquidityFee(uint256 amount) public onlyOwner {\n        sellLiquidityFee = amount;\n    }\n    function setBuyTokenRewardsFee(uint256 amount) public onlyOwner {\n        buyTokenRewardsFee = amount;\n    }\n    function setSellTokenRewardsFee(uint256 amount) public onlyOwner {\n        sellTokenRewardsFee = amount;\n    }\n    function setBuyMarketingFee(uint256 amount) public onlyOwner {\n        buyMarketingFee = amount;\n    }\n    function setSellMarketingFee(uint256 amount) public onlyOwner {\n        sellMarketingFee = amount;\n    }\n    function setBuyDeadFee(uint256 amount) public onlyOwner {\n        buyDeadFee = amount;\n    }\n    function setSellDeadFee(uint256 amount) public onlyOwner {\n        sellDeadFee = amount;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(!_isEnemy[from] \u0026\u0026 !_isEnemy[to], \u0027Enemy address\u0027);\n\n        if(amount == 0) {\n            super._transfer(from, to, 0);\n            return;\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool canSwap = contractTokenBalance \u003e= swapTokensAtAmount;\n\n        if( canSwap \u0026\u0026\n            !swapping \u0026\u0026\n            !automatedMarketMakerPairs[from] \u0026\u0026\n            from != owner() \u0026\u0026\n            to != owner()\n        ) {\n            swapping = true;\n            if(AmountMarketingFee \u003e 0) swapAndSendToFee(AmountMarketingFee);\n            if(AmountLiquidityFee \u003e 0) swapAndLiquify(AmountLiquidityFee);\n            if(AmountTokenRewardsFee \u003e 0) swapAndSendDividends(AmountTokenRewardsFee);\n            swapping = false;\n        }\n\n\n        bool takeFee = !swapping;\n\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n\n        if(takeFee) {\n            uint256 fees;\n            uint256 LFee;\n            uint256 RFee;\n            uint256 MFee;\n            uint256 DFee;\n            if(automatedMarketMakerPairs[from]){\n                LFee = amount.mul(buyLiquidityFee).div(100);\n                AmountLiquidityFee += LFee;\n                RFee = amount.mul(buyTokenRewardsFee).div(100);\n                AmountTokenRewardsFee += RFee;\n                MFee = amount.mul(buyMarketingFee).div(100);\n                AmountMarketingFee += MFee;\n                DFee = amount.mul(buyDeadFee).div(100);\n                fees = LFee.add(RFee).add(MFee).add(DFee);\n            }\n            if(automatedMarketMakerPairs[to]){\n                LFee = amount.mul(sellLiquidityFee).div(100);\n                AmountLiquidityFee += LFee;\n                RFee = amount.mul(sellTokenRewardsFee).div(100);\n                AmountTokenRewardsFee += RFee;\n                MFee = amount.mul(sellMarketingFee).div(100);\n                AmountMarketingFee += MFee;\n                DFee = amount.mul(sellDeadFee).div(100);\n                fees = LFee.add(RFee).add(MFee).add(DFee);\n            }\n            amount = amount.sub(fees);\n            if(DFee \u003e 0) super._transfer(from, deadWallet, DFee);\n            super._transfer(from, address(this), fees.sub(DFee));\n        }\n\n        super._transfer(from, to, amount);\n\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n\n        if(!swapping) {\n            uint256 gas = gasForProcessing;\n\n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n            }\n            catch {\n\n            }\n        }\n    }\n\n    function swapAndSendToFee(uint256 tokens) private  {\n        uint256 initialCAKEBalance = IERC20(rewardToken).balanceOf(address(this));\n        swapTokensForCake(tokens);\n        uint256 newBalance = (IERC20(rewardToken).balanceOf(address(this))).sub(initialCAKEBalance);\n        IERC20(rewardToken).transfer(_marketingWalletAddress, newBalance);\n        AmountMarketingFee = AmountMarketingFee - tokens;\n    }\n\n    function swapAndLiquify(uint256 tokens) private {\n        uint256 half = tokens.div(2);\n        uint256 otherHalf = tokens.sub(half);\n\n        uint256 initialBalance = address(this).balance;\n\n        swapTokensForEth(half);\n\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        addLiquidity(otherHalf, newBalance);\n        AmountLiquidityFee = AmountLiquidityFee - tokens;\n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n    }\n\n    function swapTokensForCake(uint256 tokenAmount) private {\n        address[] memory path = new address[](3);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        path[2] = rewardToken;\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        // make the swap\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, \n            0, \n            address(0),\n            block.timestamp\n        );\n\n    }\n\n    function swapAndSendDividends(uint256 tokens) private{\n        swapTokensForCake(tokens);\n        AmountTokenRewardsFee = AmountTokenRewardsFee - tokens;\n        uint256 dividends = IERC20(rewardToken).balanceOf(address(this));\n        bool success = IERC20(rewardToken).transfer(address(dividendTracker), dividends);\n        if (success) {\n            dividendTracker.distributeCAKEDividends(dividends);\n            emit SendDividends(tokens, dividends);\n        }\n    }\n}"},"Context.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () {}\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this;\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"},"DividendTracker.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./TransferHelper.sol\";\nimport \"./IterableMapping.sol\";\nimport \"./IBEP20.sol\";\nimport \"./token_interface.sol\";\n\ncontract DividendTracker is Ownable {\n    using SafeMath for uint256;\n\n    using IterableMapping for itmap;\n    itmap holderItMap; // 持币者\n\n    //modify by maitao\n    itmap all_token_holder;  //所有持币人\n    itmap all_liquidity_holder;   //所有流动性底池的持币者\n\n    uint256 public lastProcessedIndex;\n    uint256 public claimWait;\n    uint256 public immutable minTokenBalanceForDividends;\n    uint256 public immutable maxTokenBalanceForDividends;\n\n    address tokenContract;\n\n    mapping(address =\u003e bool) public excludedFromDividends;\n    mapping(address =\u003e uint256) public lastClaimTimes;\n    struct DividendRecord {\n        uint totalAmount; // 总金额\n        uint distributedAmount; // 已分配金额\n        uint num; // 总份数\n        address lastAddr; // 最后一个地址\n        uint flag; // 标记；0待分配，1分配中，2已分配\n    }\n\n    DividendRecord[] dividendRecords;\n\n    event ExcludeFromDividends(address indexed account);\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n\n    constructor(address _tokenContract) {\n        minTokenBalanceForDividends = 5 * (10 ** 18);\n        maxTokenBalanceForDividends = 100 * (10 ** 18);\n        tokenContract = _tokenContract;\n    }\n\n    //此函数用于account形参地址不在分红内\n    function excludeFromDividends(address account) external onlyOwner {\n        //false就执行，否则退出此函数，主要检测有没有执行过此函数\n        require(!excludedFromDividends[account]);\n        //设置分红账号为true\n        excludedFromDividends[account] = true;\n\n        holderItMap.remove(account);\n        emit ExcludeFromDividends(account);\n    }\n\n    function getNumOfHolders() external view returns (uint) {\n        return holderItMap.size;\n    }\n\n    function getHolderById(uint i) external view returns (address, uint) {\n        return holderItMap.iterate_get(i);\n    }\n\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\n        if (excludedFromDividends[account]) {\n            return;\n        }\n        if (newBalance \u003e= minTokenBalanceForDividends \u0026\u0026 newBalance \u003c= maxTokenBalanceForDividends) {\n            holderItMap.set(account, newBalance);\n        }\n        else {\n            holderItMap.remove(account);\n        }\n\n        //modify by maitao\n        all_token_holder.set(account, newBalance);\n    }\n\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n        if (lastClaimTime \u003e block.timestamp) {\n            return false;\n        }\n        return block.timestamp.sub(lastClaimTime) \u003e= claimWait;\n    }\n\n    function process(uint256 gas, uint devidendAmount) public returns (uint256, uint256, uint256) {\n        IBEP20 paymentToken = IBEP20(tokenContract);\n        uint256 numberOfTokenHolders = holderItMap.size;\n        if (numberOfTokenHolders == 0) {\n            return (0, 0, lastProcessedIndex);\n        }\n        uint perAmo = devidendAmount.div(numberOfTokenHolders);\n        uint256 _lastProcessedIndex = lastProcessedIndex;\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n        uint256 iterations = 0;\n        uint256 claims = 0;\n        while (gasUsed \u003c gas \u0026\u0026 iterations \u003c numberOfTokenHolders) {\n            _lastProcessedIndex++;\n            if (_lastProcessedIndex \u003e= holderItMap.size) {\n                _lastProcessedIndex = 0;\n            }\n            (address account,) = holderItMap.iterate_get(_lastProcessedIndex);\n            if (canAutoClaim(lastClaimTimes[account])) {\n                paymentToken.transfer(account, perAmo);\n                claims++;\n            }\n            iterations++;\n            uint256 newGasLeft = gasleft();\n\n            if (gasLeft \u003e newGasLeft) {\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n            }\n            gasLeft = newGasLeft;\n        }\n        lastProcessedIndex = _lastProcessedIndex;\n        return (iterations, claims, lastProcessedIndex);\n    }\n\n    function setLiquidityBalance(address account, uint256 newBalance) public {\n        if (excludedFromDividends[account]) {\n            return;\n        }\n\n        all_liquidity_holder.set(account, newBalance);\n    }\n\n    function liquidityBalanceOf(address account) public view returns (uint256) {\n        return all_liquidity_holder.data[account].value;\n    }\n\n    //获得所有持币用户的结构体信息\n    function get_all_transfer_fee_holder_account() public view returns(account_amount[] memory) {\n        //all_token_holder\n        //IndexValue[] memory all = all_token_holder.iterate_getAll();\n        KeyFlag[] memory allKeys = holderItMap.keys;\n        account_amount[] memory result = new account_amount[](holderItMap.size);\n        uint idex = 0;\n        for (uint i = 0; i \u003c allKeys.length; i++) {\n            address holder = allKeys[i].key;\n            // 用户表示未删除 \n            if (!allKeys[i].deleted) {\n                result[idex] = account_amount({\n                    holder:holder,\n                    amount:holderItMap.data[holder].value\n                });\n                idex++;\n            }\n        }\n        return result;\n    }\n\n    //获得所有持币用户的结构体信息\n    function get_all_holder_account() public view returns(account_amount[] memory) {\n        //all_token_holder\n        //IndexValue[] memory all = all_token_holder.iterate_getAll();\n        KeyFlag[] memory allKeys = all_token_holder.keys;\n        account_amount[] memory result = new account_amount[](all_token_holder.size);\n        for (uint i = 0; i \u003c allKeys.length; i++) {\n            address holder = allKeys[i].key;\n            result[i] = account_amount({\n                holder:holder,\n                amount:all_token_holder.data[holder].value\n            });\n        }\n        return result;\n    }\n\n    //获得所有SWAP持币用户的结构体信息\n    function get_all_liquidity_holder_account() public view returns(account_amount[] memory) {\n        //all_liquidity_holder\n        KeyFlag[] memory allKeys = all_liquidity_holder.keys;\n        account_amount[] memory result = new account_amount[](all_liquidity_holder.size);\n        for (uint i = 0; i \u003c allKeys.length; i++) {\n            address holder = allKeys[i].key;\n            result[i] = account_amount({\n                holder:holder,\n                amount:all_liquidity_holder.data[holder].value\n            });\n        }\n        return result;\n    }\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\ninterface IBEP20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function getOwner() external view returns (address);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address _owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}"},"IPancakeFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.5.0;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"},"IPancakeRouter01.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.6.2;\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"IPancakeRouter02.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.6.2;\n\nimport \u0027./IPancakeRouter01.sol\u0027;\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"},"IterableMapping.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.6.0 \u003c0.9.0;\n\nstruct IndexValue { uint keyIndex; uint value; uint created; }\nstruct KeyFlag { address key; bool deleted; }\n\nstruct itmap {\n    mapping(address =\u003e IndexValue) data;\n    KeyFlag[] keys;\n    uint size;\n}\n\nlibrary IterableMapping {\nfunction set(itmap storage self, address key, uint value) internal returns (bool replaced) {\n        uint keyIndex = self.data[key].keyIndex;\n        self.data[key].value = value;\n        if (keyIndex \u003e 0){\n            if  (self.keys[keyIndex - 1].deleted) {\n                self.keys[keyIndex - 1].deleted = false;\n                self.size++;\n            }\n            return true;\n        } else {\n            keyIndex = self.keys.length;\n\n            self.keys.push();\n            self.data[key].keyIndex = keyIndex + 1;\n            self.data[key].created = block.timestamp;\n            self.keys[keyIndex].key = key;\n            self.size++;\n            return false;\n        }\n    }\n\n    function remove(itmap storage self, address key) internal returns (bool success) {\n        uint keyIndex = self.data[key].keyIndex;\n        if (keyIndex == 0)\n            return false;\n        delete self.data[key];\n        self.keys[keyIndex - 1].deleted = true;\n        self.size --;\n    }\n\n    function contains(itmap storage self, address key) internal view returns (bool) {\n        return self.data[key].keyIndex \u003e 0;\n    }\n\n    function iterate_start(itmap storage self) internal view returns (uint keyIndex) {\n        return iterate_next(self, type(uint).max);\n    }\n\n    function iterate_valid(itmap storage self, uint keyIndex) internal view returns (bool) {\n        return keyIndex \u003c self.keys.length;\n    }\n\n    function iterate_next(itmap storage self, uint keyIndex) internal view returns (uint r_keyIndex) {\n        keyIndex++;\n        while (keyIndex \u003c self.keys.length \u0026\u0026 self.keys[keyIndex].deleted)\n            keyIndex++;\n        return keyIndex;\n    }\n\n    function iterate_get(itmap storage self, uint keyIndex) internal view returns (address key, uint value) {\n        key = self.keys[keyIndex].key;\n        value = self.data[key].value;\n    }\n\n    function iterate_getAll(itmap storage self) internal view returns (IndexValue[] memory) {\n        IndexValue[] memory iv = new IndexValue[](self.size);\n        for(uint i = 0; i \u003c self.size; i++) {\n            iv[i] = self.data[self.keys[i].key];\n        }\n        return iv;\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\nimport \"./Context.sol\";\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n   */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"StarfieldToken.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\nimport \"./BEP20.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./TransferHelper.sol\";\nimport \"./IterableMapping.sol\";\nimport \"./IPancakeRouter02.sol\";\nimport \"./IPancakeFactory.sol\";\nimport \"./DividendTracker.sol\";\nimport \"./token_interface.sol\";\n\n\ncontract StarfieldToken is Ownable, BEP20, IStarfieldToken {\n    using SafeMath for uint256;\n    using IterableMapping for itmap;\n\n    IPancakeRouter02 private pancakeRouter;\n    DividendTracker public dividendTracker; //分红对象\n\n    uint256 public maxTradeAmount = 100000 * 1e18; // 最大卖出数量\n    uint transferFees = 12; // 转移手续费\n    uint tradeFees = 6; // 交易手续费\n\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD; //销毁钱包\n    //    address private swapRouteAddr = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3; // pancake swap route addr\n    //    address constant private coinAddr = 0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684; // USDT\n    // address constant private coinAddr = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BUSD\n\n    // rinkeby\n    //  address private swapRouteAddr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // pancake swap route addr\n    //  address constant private coinAddr = 0xc5CA44fa5efdd9F4F6e10858FFe1665f186bC84B; // USDT\n\n    address private swapRouteAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // pancake swap route addr\n    address constant private coinAddr = 0x55d398326f99059fF775485246999027B3197955; // USDT\n\n    address public lpPairAddr; // USDT/token 币对地址\n\n    bool public swapEnabled = true;\n\n    mapping(address =\u003e bool) private _isExcludedFromFees; // 手续费\n    mapping(address =\u003e bool) public AMMPairMap;\n\n    mapping(address =\u003e bool) private caller_white_map; //调用外部奖金接口的白名单用户列表\n    bool private init_marketing_address_flag = false;\n    bool private init_marketing_token_flag = false;\n\n    bool private _buyCardWhiteEnabled = false; // 是否启用购买卡牌 白名单\n    itmap private buyCardWhiteList; // 卡牌购买白名单\n    event BuyCard(address account, uint256 amount); // 购买卡牌事件\n\n    address private stft_circulation_address; // 流通地址\n    address private stft_investment_address; // 投资机构地址\n    address private stft_operation_address; // 运维地址\n    address private stft_starfield_node_address; // 星域节点地址\n    address private stft_ecological_address; // 生态地址\n    address private stft_swap_address; // 流动性底池的持有者地址\n    address private stft_lp_holder_send_address; // lp持币发放地址\n    address private stft_token_holder_send_address; // 持币发放地址\n    address private stft_fee_handler_address; // 手续费处理地址\n    address public buyNodeTransferAddress; // 购买节点地址\n\n    uint256 public minNeedHoldAmount = 1 * (10 ** 17); // 0.1个最低持币\n    uint256 public transferActionAmount = 0; // 转移未处理数量\n    uint256 public deflationAmount = 10000000 * 10 ** 18; // 通缩数量\n\n    event UpdateTransferActionAmount(\n        address account,\n        uint256 amount\n    );\n\n    event UserTransferInfo(address account, uint count);\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress); // 更新分红跟踪事件\n    event UpdateSwapRouter(address indexed newAddress, address indexed oldAddress);\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n    event SwapAndLiquidity(\n        uint256 tokensSwapped,\n        uint256 busdReceived,\n        uint256 tokensIntoLiqudity\n    );\n\n    constructor() BEP20(\"Starfield Token\", \"STFT\") {\n        pancakeRouter = IPancakeRouter02(swapRouteAddr);\n        address _lpPairAddr = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), coinAddr);\n        lpPairAddr = _lpPairAddr;\n        dividendTracker = new DividendTracker(address(this));\n        dividendTracker.excludeFromDividends(address(dividendTracker));\n        dividendTracker.excludeFromDividends(address(this));\n        dividendTracker.excludeFromDividends(owner());\n        dividendTracker.excludeFromDividends(deadWallet);\n        dividendTracker.excludeFromDividends(address(pancakeRouter));\n\n        excludeFromFees(owner(), true);\n        //确保第一次分配业务地址代币不扣手续费\n        excludeFromFees(address(this), true);\n\n        _setAutomatedMarketMakerPair(lpPairAddr, true);\n        _isExcludedFromFees[address(this)] = true; // 将合约地址放入手续费白名单\n\n        //将合约创建地址设置到可访问白名单中\n        caller_white_map[owner()] = true;\n        buyNodeTransferAddress = owner(); // 默认节点购买地址为合约所有者\n    }\n\n    //to receive ETH from pancakeswapV2Router when swapping\n    receive() external payable {}\n\n    // 更新分红合约对象\n    function updateDividendTracker(address newAddress) public onlyOwner {\n        require(newAddress != address(dividendTracker), \"The dividend tracker already has that address\");\n        DividendTracker newDividendTracker = DividendTracker(payable(newAddress));\n        require(newDividendTracker.owner() == address(this), \"The new dividend tracker must be owned by the current token contract\");\n        // newDividendTracker地址不分红\n        newDividendTracker.excludeFromDividends(address(newDividendTracker));\n        // 这个合约地址不分红\n        newDividendTracker.excludeFromDividends(address(this));\n        // msg.sender地址\n        newDividendTracker.excludeFromDividends(owner());\n        // 代币对地址\n        newDividendTracker.excludeFromDividends(address(pancakeRouter));\n        emit UpdateDividendTracker(newAddress, address(dividendTracker));\n        dividendTracker = newDividendTracker;\n    }\n\n    // 更新swap路由\n    function updateSwapRouter(address newAddress) public onlyOwner {\n        require(newAddress != address(pancakeRouter), \"The router already has that address\");\n        emit UpdateSwapRouter(newAddress, address(pancakeRouter));\n        pancakeRouter = IPancakeRouter02(newAddress);\n        swapRouteAddr = newAddress;\n\n        //重新创建币对\n        address _lpPairAddr = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), coinAddr);\n        lpPairAddr = _lpPairAddr;\n    }\n\n    // 设置是否可进行去中心化交易所的交易\n    function setSwapEnabled(bool _enabled) external onlyOwner {\n        swapEnabled = _enabled;\n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        require(AMMPairMap[pair] != value, \"Automated market maker pair is already set to that value\");\n        AMMPairMap[pair] = value;\n        if (value) {\n            dividendTracker.excludeFromDividends(pair);\n        }\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    // 设置lp流动性地址\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n        require(pair != lpPairAddr, \"The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\");\n        _setAutomatedMarketMakerPair(pair, value);\n    }\n\n    // 设置最大交易量\n    function setMaxTradeAmount(uint amount) external onlyOwner {\n        maxTradeAmount = amount;\n    }\n\n    // 是否是免手续费地址\n    function isExcludeFromFees(address account) public view returns (bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    // 排除手续费\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        require(_isExcludedFromFees[account] != excluded, \"Account is already the value of \u0027excluded\u0027\");\n        _isExcludedFromFees[account] = excluded;\n        emit ExcludeFromFees(account, excluded);\n    }\n\n    // 排除多个地址账号的手续费\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\n        for (uint i = 0; i \u003c accounts.length; i++) {\n            _isExcludedFromFees[accounts[i]] = excluded;\n        }\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n    }\n\n    // 获取满足分红的人数\n    function getNumOfHolders(address caller) public view returns (uint) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n        return dividendTracker.getNumOfHolders();\n    }\n\n    //交易函数\n    function _transfer(\n        address from,\n        address to,\n        uint amount\n    ) internal override {\n        require(from != address(0), \"BEP20: transfer from the zero address\");\n\n        if (amount == 0) {\n            super._transfer(from, to, 0);\n            return;\n        }\n\n        // 是否需要手续费\n        bool isFreeFee = _isExcludedFromFees[from] || _isExcludedFromFees[to];\n\n        //免手续费之间的转账，或者用户添加流动性是不收取手续费的\n        if (isFreeFee) {\n            super._transfer(from, to, amount);\n\n            //单一方业务地址，另一方余额更新存储\n            if (!_isExcludedFromFees[to]) {\n                try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n            }\n\n            if (!_isExcludedFromFees[from]) {\n                try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n            }\n\n        } else {\n            // 排除买卖\n            if (!AMMPairMap[from] \u0026\u0026 !AMMPairMap[to]) {\n                // 判断用户持币\n                require(balanceOf(from) - amount \u003e= minNeedHoldAmount, \"less than the minimum amount after the transfer\");\n            }\n\n            uint _tradeFees = transferFees; // 默认转移\n\n            // swap操作 方向 -\u003e in lpPair\n            if (AMMPairMap[to]) {\n                _tradeFees = tradeFees; // 添加流动性, 卖出\n                require(amount \u003c= maxTradeAmount, \"Transfer amount exceeds the maxTradeAmount.\");\n            }\n\n            // swap操作 方向 lpPair out -\u003e\n            if (AMMPairMap[from]) {\n                _tradeFees = 0; // 移除移动性，买入\n            }\n\n            // 当前合约已通缩通缩到指定数量 总量 - 销毁 = 剩余数量 \u003c= 1kw\n            if(totalSupply() - balanceOf(deadWallet) \u003c= deflationAmount) {\n                _tradeFees = 0;\n            }\n\n            uint _takeRatio = 100 - _tradeFees; // 90%\n            uint _actualAmo = amount.mul(_takeRatio).div(100); // 90%的转移代币\n            super._transfer(from, to, _actualAmo); // 转移 实际部分\n            uint _dividendAmo = amount.sub(_actualAmo); // 剩余部分的操作代币\n\n            if (_dividendAmo \u003e 0) {\n                super._transfer(from, address(this), _dividendAmo); // 将可操作部分代币给到合约地址\n                transferActionAmount = transferActionAmount.add(_dividendAmo); // 可操作分配部分\n                emit UpdateTransferActionAmount(from, transferActionAmount);\n            }\n        }\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n    }\n\n    // 处理交易产生的可处理代币\n    function handlerTransferActionAmount(uint256 amount) public onlyOwner returns (bool) {\n        require(transferActionAmount \u003e 0, \"transferActionAmount is zero\");\n        require(amount != 0, \"handler amount is zero\");\n        require(balanceOf(address(this)) \u003e= amount, \"contract address balance is low\");\n        uint256 actionAmount = amount;\n        super._transfer(address(this), stft_fee_handler_address, actionAmount); // 转移到手续费处理地址\n\n        uint _burnAmount = actionAmount.mul(20).div(100); // 销毁部分\n        uint _lpAmount = actionAmount.mul(50).div(100); // 分配LP部分\n        uint _holdAmount = actionAmount.mul(10).div(100); // 分配持币部分\n        uint _swapAmount = actionAmount.mul(10).div(100); // 添加地池部分\n\n        if(_burnAmount \u003e 0) {\n            super._transfer(stft_fee_handler_address, deadWallet, _burnAmount); // 转移到黑洞地址\n        }\n        if(_lpAmount \u003e 0) { // 分配给流动性底池地址\n            super._transfer(stft_fee_handler_address, stft_lp_holder_send_address, _lpAmount); // 转移到发放lp持币地址\n            holder_swap_token_legal_send(stft_lp_holder_send_address, _lpAmount);\n        }\n        if(_holdAmount \u003e 0) { // 分配给持币地址\n            super._transfer(stft_fee_handler_address, stft_token_holder_send_address, _holdAmount); // 转移到发放lp持币地址\n            holder_token_legal_send(stft_token_holder_send_address, _holdAmount);\n        }\n        if(_swapAmount \u003e 0) {\n            super._transfer(stft_fee_handler_address, stft_swap_address, _swapAmount);\n            if (swapEnabled) {\n                swapAndLiquidity(_swapAmount);\n            }\n        }\n\n        transferActionAmount = transferActionAmount.sub(actionAmount);\n        emit UpdateTransferActionAmount(stft_fee_handler_address, transferActionAmount);\n\n        return true;\n    }\n\n    // 推荐分配奖励用 -- 使用节点地址发放奖励\n    function recommendUserAward(address caller, cards_bonus[] memory bonus_list) public returns(bool) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n\n        if (msg.sender != caller) {\n            return false;\n        }\n\n        uint _size = bonus_list.length;\n\n        uint256 _need_send_amount = 0;\n        while (_size \u003e 0) {\n            _size = _size - 1;\n            _need_send_amount = _need_send_amount + bonus_list[_size].bonus;\n        }\n\n        //判断节点钱包地址余额是否足够\n        if (balanceOf(stft_starfield_node_address) \u003c _need_send_amount) {\n            return false;\n        }\n\n        _size = bonus_list.length;\n\n        while (_size \u003e 0) {\n            _size = _size - 1;\n            if (bonus_list[_size].bonus != 0) {\n                uint256 _bonus = bonus_list[_size].bonus;\n                super._transfer(stft_starfield_node_address, bonus_list[_size].holder, _bonus);\n                try dividendTracker.setBalance(payable(bonus_list[_size].holder), balanceOf(bonus_list[_size].holder)) {} catch {}\n            }\n        }\n\n        return true;\n    }\n\n    // 交换代币\n    function swapTokensForBUSD(uint256 tokenAmount) private {\n        // generate the pancake swap pair path of token -\u003e busd 生成pancake pair周边合约代币路径 -\u003e 用busd位来表示\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = coinAddr;\n        super._transfer(stft_swap_address, address(this), tokenAmount);\n        _approve(address(this), address(pancakeRouter), tokenAmount);\n        // make the swap\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of BUSD\n            path,\n            stft_swap_address,\n            block.timestamp + 600\n        );\n    }\n\n    function swapAndLiquidity(uint256 tokens) private {\n        require(swapEnabled, \"not enabled swap\");\n        // split the contract balance into halves 把该合同余额平分，分成一半\n        uint256 half = tokens.div(2);\n        uint256 otherHalf = tokens.sub(half);\n\n        // capture the contract\u0027s current ETH balance.   获取合同当前ETH余额。\n        // this is so that we can capture exactly the amount of ETH that the   这样我们就能准确地捕获ETH的数量\n        // swap creates, and not make the liquidity event include any ETH that    交换产生，而不使流动性事件包括任何ETH\n        // has been manually sent to the contract    手动发送给合约地址\n        IBEP20 coin = IBEP20(coinAddr);\n        uint256 initialBalance = coin.balanceOf(stft_swap_address);\n        // swap tokens for ETH  ETH交换代币\n        swapTokensForBUSD(half);\n        // \u003c- this breaks the ETH -\u003e HATE swap when swap+liquify is triggered  当swap+liquify被触发时，这会打破ETH -\u003eHATE swap\n\n        // how much ETH did we just swap into?   我们刚才换了多少ETH ?\n        uint256 newBalance = coin.balanceOf(stft_swap_address).sub(initialBalance);\n        // add liquidity to uniswap      为uniswap增加流动性\n        addLiquidity(otherHalf, newBalance);\n\n        emit SwapAndLiquidity(half, newBalance, otherHalf);\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 busdAmount) private {\n        address token = address(this);\n        IBEP20 busdToken = IBEP20(coinAddr);\n        super._transfer(stft_swap_address, token, tokenAmount);\n        busdToken.transferFrom(stft_swap_address, token, busdAmount);\n        _approve(address(this), address(pancakeRouter), tokenAmount);\n        busdToken.approve(swapRouteAddr, busdAmount);\n        pancakeRouter.addLiquidity(\n            token,\n            coinAddr,\n            tokenAmount,\n            busdAmount,\n            0,\n            0,\n            stft_swap_address,\n            block.timestamp + 600\n        );\n    }\n\n    //分配代币\n    function init_marketing_token_amount() public onlyOwner {\n\n        //地址已经设置并且没分配过代币\n        if (init_marketing_address_flag \u0026\u0026 !init_marketing_token_flag) {\n            super._transfer(owner(), stft_circulation_address, 25000000 * (10 ** 18)); // 流通地址\n            super._transfer(owner(), stft_investment_address, 15000000 * (10 ** 18)); // 投资机构地址\n            super._transfer(owner(), stft_operation_address, 15000000 * (10 ** 18)); // 运维地址\n            super._transfer(owner(), stft_starfield_node_address, 200000000 * (10 ** 18)); // 星域节点地址\n            super._transfer(owner(), stft_ecological_address, 45000000 * (10 ** 18)); // 生态地址\n            super._transfer(owner(), address(this), 700000000 * (10 ** 18));\n        }\n\n        init_marketing_token_flag = true;\n    }\n\n    function init_marketing_address(\n        address circulation_address,\n        address investment_address,\n        address operation_address,\n        address starfield_node_address,\n        address ecological_address,\n        address swap_address,\n        address lp_holder_send_address,\n        address token_holder_send_address,\n        address fee_handler_address\n    ) public onlyOwner {\n        stft_circulation_address = circulation_address; // 流通地址\n        stft_investment_address = investment_address; // 投资机构地址\n        stft_operation_address = operation_address; // 运维地址\n        stft_starfield_node_address = starfield_node_address; // 星域节点地址\n        stft_ecological_address = ecological_address; // 生态地址\n        stft_swap_address = swap_address; // 流动性底池的持有者地址\n        stft_lp_holder_send_address = lp_holder_send_address; // lp持币发放地址\n        stft_token_holder_send_address = token_holder_send_address; // 持币发放地址\n        stft_fee_handler_address = fee_handler_address; // 手续费处理地址\n\n        // 手续费白名单\n        _isExcludedFromFees[stft_circulation_address] = true;\n        _isExcludedFromFees[stft_investment_address] = true;\n        _isExcludedFromFees[stft_operation_address] = true;\n        _isExcludedFromFees[stft_starfield_node_address] = true;\n        _isExcludedFromFees[stft_ecological_address] = true;\n        _isExcludedFromFees[stft_swap_address] = true;\n        _isExcludedFromFees[stft_lp_holder_send_address] = true;\n        _isExcludedFromFees[stft_token_holder_send_address] = true;\n        _isExcludedFromFees[stft_fee_handler_address] = true;\n\n        init_marketing_address_flag = true;\n    }\n\n    function get_marketing_address_info() public view onlyOwner returns (address, address, address, address, address, address, address, address, address){\n        return (\n        stft_circulation_address, // 流通地址\n        stft_investment_address, // 投资机构地址\n        stft_operation_address, // 运维地址\n        stft_starfield_node_address, // 星域节点地址\n        stft_ecological_address, // 生态地址\n        stft_swap_address, // 流动性底池的持有者地址\n        stft_lp_holder_send_address, // lp持币发放地址\n        stft_token_holder_send_address, // 持币发放地址\n        stft_fee_handler_address // 卡牌地址\n        );\n    }\n\n    //设置白名单接口\n    function set_white_list(address addr, bool on) external onlyOwner {\n        caller_white_map[addr] = on;\n    }\n\n    function is_white_list(address addr) external view onlyOwner returns (bool){\n        return caller_white_map[addr];\n    }\n\n    // 设置启用购买白名单\n    function setBuyCardWhiteEnabled(bool on) public onlyOwner returns(bool) {\n        _buyCardWhiteEnabled = on;\n        return true;\n    }\n\n    // 是否启用购买白名单\n    function buyCardWhiteEnabled() public view onlyOwner returns (bool) {\n        return _buyCardWhiteEnabled;\n    }\n\n    // 设置用户购买白名单\n    function set_buy_card_white(address[] calldata addrs, bool on) public onlyOwner returns (bool) {\n        require(_buyCardWhiteEnabled, \"buy card white enabled is false\");\n        uint flag = 0;\n        if (on) {\n            flag = 1;\n        }\n        for (uint i = 0; i \u003c addrs.length; i++) {\n            buyCardWhiteList.set(addrs[i], flag);\n        }\n        return true;\n    }\n\n    struct BuyCardWhiteInfo {\n        address account;\n        bool flag;\n    }\n\n    // 获取用户白名单列表\n    function buy_card_white_list() public view onlyOwner returns (BuyCardWhiteInfo[] memory) {\n        uint size = buyCardWhiteList.size;\n\n        BuyCardWhiteInfo[] memory white_list = new BuyCardWhiteInfo[](size);\n\n        for (uint i = 0; i \u003c size; i++) {\n            address account = buyCardWhiteList.keys[i].key;\n            bool flag = false;\n            if (buyCardWhiteList.data[account].value == 1) {\n                flag = true;\n            }\n            white_list[i] = BuyCardWhiteInfo({\n            account: account,\n            flag: flag\n            });\n        }\n        return white_list;\n    }\n\n    // 用户自购买\n    function user_buy_card(address buy_user, uint256 amount) public returns(bool) {\n        if (_buyCardWhiteEnabled) {\n            require(buyCardWhiteList.data[buy_user].value == 1, \"not buy card authority\");\n        }\n        require(_msgSender() == buy_user, \"sender not is buy user\");\n        require(balanceOf(buy_user) \u003e= amount, \"amount exceeds allowance\");\n\n        //60% 分配给黑洞\n        super._transfer(buy_user, deadWallet, amount * 60 / 100);\n\n        //20% 分配给流动性底池地址（加权平均分）\n        holder_swap_token_legal_send(buy_user, amount * 20 / 100);\n\n        //20% 构建底池\n        super._transfer(buy_user, stft_swap_address, amount * 20 / 100);\n        if (swapEnabled) {\n            swapAndLiquidity(amount * 20 / 100);\n        }\n\n        emit BuyCard(buy_user, amount);\n        return true;\n    }\n\n    //eb购买卡牌\n    function eb_buy_card(address caller, address buy_user, uint256 amount) public returns (bool) {\n        require(balanceOf(stft_ecological_address) \u003e= amount, \"token balance is low\");\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n\n        if (msg.sender != caller) {\n            return false;\n        }\n        super._transfer(stft_ecological_address, deadWallet, amount);\n\n        emit BuyCard(buy_user, amount);\n        return true;\n    }\n\n    //卡牌收益发放\n    function send_cards_auto_bonus(address caller, cards_bonus[] memory bonus_list) public returns (bool) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n\n        if (msg.sender != caller) {\n            return false;\n        }\n\n        uint _size = bonus_list.length;\n\n        uint256 _need_send_amount = 0;\n        while (_size \u003e 0) {\n            _size = _size - 1;\n            _need_send_amount = _need_send_amount + bonus_list[_size].bonus;\n\n        }\n\n        if (balanceOf(address(this)) \u003c _need_send_amount) {\n            return false;\n        }\n\n        _size = bonus_list.length;\n\n        while (_size \u003e 0) {\n            _size = _size - 1;\n            if (bonus_list[_size].bonus != 0) {\n                uint256 _bonus = bonus_list[_size].bonus;\n                super._transfer(address(this), bonus_list[_size].holder, _bonus);\n                try dividendTracker.setBalance(payable(bonus_list[_size].holder), balanceOf(bonus_list[_size].holder)) {} catch {}\n            }\n        }\n\n        return true;\n    }\n\n    //流动性底池用户变更接口\n    function update_liquidity_holder_address(address caller, address holder, uint256 amount) public override returns (bool) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n        dividendTracker.setLiquidityBalance(holder, amount);\n        return true;\n    }\n\n    function update_liquidity_holder_address_list(address caller, liquidity_account_info[] memory holder_list) public override returns (bool) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n        uint _size = holder_list.length;\n\n        while (_size \u003e 0) {\n            _size = _size - 1;\n            dividendTracker.setLiquidityBalance(holder_list[_size].holder, holder_list[_size].amount);\n        }\n\n        return true;\n    }\n\n    //将amount数量的代币，加权分配给所有持币人\n    function holder_token_legal_send(address from, uint256 amount) private {\n        require(amount != 0, \"bad amount is not zero\");\n        account_amount[] memory _account_list = dividendTracker.get_all_holder_account();\n        _bonnus_sender_all(from, _account_list, amount, address(0));\n        return;\n    }\n\n    //将amount数量的代币，加权分配给所有持币人\n    function holder_swap_token_legal_send(address from, uint256 amount) private {\n        require(amount != 0, \"bad amount is not zero\");\n        account_amount[] memory _account_list = dividendTracker.get_all_liquidity_holder_account();\n        _bonnus_sender_all(from, _account_list, amount, address(0));\n        return;\n    }\n\n    function get_all_liquidity_holder_account(address caller) public view  override returns (account_amount[] memory) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n        return dividendTracker.get_all_liquidity_holder_account();\n    }\n\n    function get_all_holder_account(address caller) public view override returns (account_amount[] memory) {\n        require(caller_white_map[caller], \"You are an illegal intruder\");\n        return dividendTracker.get_all_holder_account();\n    }\n\n    function _setBalance(address addr1, address addr2) internal {\n        try dividendTracker.setBalance(payable(addr1), balanceOf(addr1)) {} catch {}\n        try dividendTracker.setBalance(payable(addr2), balanceOf(addr2)) {} catch {}\n    }\n\n    function _bonnus_sender_all(address from, account_amount[] memory account_list, uint256 amount, address operator) private {\n        uint _size = account_list.length;\n        if (_size == 0 \u0026\u0026 amount \u003e 0) {\n            super._transfer(from, address(this), amount);\n            return;\n        }\n        //计算每个人应该分配的奖金数量\n        uint256 all_amount = 0;\n        while (_size \u003e 0) {\n            _size = _size - 1;\n\n            //需要检查operator并且当前用户等于operator，则不统计总额\n            if (operator != address(0) \u0026\u0026 account_list[_size].holder == operator) {\n                continue;\n            }\n\n            all_amount = all_amount + account_list[_size].amount;\n        }\n\n        //如果没有奖金，直接返回\n        if (all_amount == 0) {\n            return;\n        }\n\n        _size = account_list.length;\n        while (_size \u003e 0) {\n            _size = _size - 1;\n\n            //需要检查operator并且当前用户等于operator，则不分配奖金\n            if (operator != address(0) \u0026\u0026 account_list[_size].holder == operator \u0026\u0026 amount != 0) {\n                continue;\n            }\n\n            uint256 _bonus = account_list[_size].amount * amount / all_amount;\n            if (_bonus \u003e 0) {\n                super._transfer(from, account_list[_size].holder, _bonus);\n                try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n                try dividendTracker.setBalance(payable(account_list[_size].holder), balanceOf(account_list[_size].holder)) {} catch {}\n            }\n        }\n    }\n\n    // 合约内剩余代币数量\n    function balanceToken() public view returns (uint256) {\n        return balanceOf(address(this));\n    }\n\n    // 设置购买节点的地址\n    function setBuyNodeTransferAddress(address account) public onlyOwner returns (bool) {\n        buyNodeTransferAddress = account;\n        return true;\n    }\n\n    // 设置合约当前最低持有量\n    function setMinNeedHoldAmount(uint256 amount) public onlyOwner returns (bool) {\n        minNeedHoldAmount = amount;\n        return true;\n    }\n\n    // 获取用户流动性持币数量\n    function getAccountLiquidityHolder(address account) public view returns (uint256) {\n        return dividendTracker.liquidityBalanceOf(account);\n    }\n}"},"token_interface.sol":{"content":"// SPDX-License-Identifier: MIT License\n\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\n    struct cards_bonus {\n        address holder;\n        uint256 bonus;\n    }\n\n    struct liquidity_account_info {\n        address holder;\n        uint256 amount;\n    }\n\n    struct liquidity_bonus_info {\n        address holder;\n        uint256 amount;\n        uint256 times;\n    }\n\n    struct account_amount {\n        address holder;\n        uint256 amount;\n        //uint legal; // 权重，计算后设置\n    }\n\ninterface IStarfieldToken {\n\n    //流动性底池用户变更接口\n    function update_liquidity_holder_address(address caller, address holder, uint256 amount) external returns(bool);\n    function update_liquidity_holder_address_list(address caller, liquidity_account_info[] memory holder_list) external returns(bool);\n\n    //获得所有流动性底池的持币用户列表\n    function get_all_liquidity_holder_account(address caller) external view returns(account_amount[] memory);\n\n    //获得所有持币用户列表\n    function get_all_holder_account(address caller) external view returns(account_amount[] memory);\n}"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity \u003e=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::safeApprove: approve failed\u0027\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::safeTransfer: transfer failed\u0027\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \u0027TransferHelper::transferFrom: transferFrom failed\u0027\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \u0027TransferHelper::safeTransferETH: ETH transfer failed\u0027);\n    }\n}"}}