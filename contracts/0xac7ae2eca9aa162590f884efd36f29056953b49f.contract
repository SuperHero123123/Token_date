// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
   
    function totalSupply() external view returns (uint256);

   
    function balanceOf(address account) external view returns (uint256);

   
    function transfer(address recipient, uint256 amount) external returns (bool);

   
    function allowance(address owner, address spender) external view returns (uint256);

   
    function approve(address spender, uint256 amount) external returns (bool);

   
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

   
    event Transfer(address indexed from, address indexed to, uint256 value);

   
    event Approval(address indexed owner, address indexed spender, uint256 value);
}





pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
   
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

   
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

   
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

   
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

   
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

   
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

   
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

   
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

   
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

   
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

   
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

   
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

   
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}





pragma solidity >=0.6.0 <0.8.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https:
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

   
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

   
    function name() public view virtual returns (string memory) {
        return _name;
    }

   
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

   
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

   
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

   
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

   
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

   
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

   
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

   
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

   
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

   
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

   
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

   
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

   
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

   
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

   
    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }

   
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}




pragma solidity >=0.6.0 <0.8.0;


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

   
    constructor() public {
        _setOwner(_msgSender());
    }

   
    function owner() public view virtual returns (address) {
        return _owner;
    }

   
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

   
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

   
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev https:
 * deploying minimal proxy contracts, also known as "clones".
 *
 * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 *
 * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 * deterministic method.
 *
 * _Available since v3.4._
 */
library Clones {
   
    function clone(address implementation) internal returns (address instance) {
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, implementation))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            instance := create(0, ptr, 0x37)
        }
        require(instance != address(0), "ERC1167: create failed");
    }

   
    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, implementation))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            instance := create2(0, ptr, 0x37, salt)
        }
        require(instance != address(0), "ERC1167: create2 failed");
    }

   
    function predictDeterministicAddress(
        address implementation,
        bytes32 salt,
        address deployer
    ) internal pure returns (address predicted) {
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, implementation))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)
            mstore(add(ptr, 0x38), shl(0x60, deployer))
            mstore(add(ptr, 0x4c), salt)
            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))
            predicted := keccak256(add(ptr, 0x37), 0x55)
        }
    }

   
    function predictDeterministicAddress(address implementation, bytes32 salt)
        internal
        view
        returns (address predicted)
    {
        return predictDeterministicAddress(implementation, salt, address(this));
    }
}




pragma solidity >=0.6.0 <0.8.0;

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}




pragma solidity >=0.6.0 <0.8.0;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);
}




pragma solidity >=0.6.0 <0.8.0;


interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}





pragma solidity >=0.6.2 <0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
   
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }

   
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

   
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

   
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

   
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

   
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

   
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

   
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

   
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

   
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}




pragma solidity >=0.6.0 <0.8.0;




interface DividendPayingTokenInterface {
    
    
    
    function dividendOf(address _owner) external view returns (uint256);

    
    
    
    function withdrawDividend() external;

    
    
    
    event DividendsDistributed(address indexed from, uint256 weiAmount);

    
    
    
    event DividendWithdrawn(address indexed to, uint256 weiAmount);
}




pragma solidity >=0.6.0 <0.8.0;




interface DividendPayingTokenOptionalInterface {
    
    
    
    function withdrawableDividendOf(address _owner)
        external
        view
        returns (uint256);

    
    
    
    function withdrawnDividendOf(address _owner)
        external
        view
        returns (uint256);

    
    
    
    
    function accumulativeDividendOf(address _owner)
        external
        view
        returns (uint256);
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @title SafeMathUint
 * @dev Math operations with safety checks that revert on error
 */
library SafeMathUint {
    function toInt256Safe(uint256 a) internal pure returns (int256) {
        int256 b = int256(a);
        require(b >= 0);
        return b;
    }
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @title SafeMathInt
 * @dev Math operations for int256 with overflow safety checks.
 */
library SafeMathInt {
    int256 private constant MIN_INT256 = int256(1) << 255;
    int256 private constant MAX_INT256 = ~(int256(1) << 255);

   
    function mul(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a * b;

        
        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
        require((b == 0) || (c / b == a));
        return c;
    }

   
    function div(int256 a, int256 b) internal pure returns (int256) {
        
        require(b != -1 || a != MIN_INT256);

        
        return a / b;
    }

   
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a));
        return c;
    }

   
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a));
        return c;
    }

   
    function abs(int256 a) internal pure returns (int256) {
        require(a != MIN_INT256);
        return a < 0 ? -a : a;
    }

    function toUint256Safe(int256 a) internal pure returns (uint256) {
        require(a >= 0);
        return uint256(a);
    }
}




pragma solidity >=0.6.0 <0.8.0;















contract DividendPayingToken is
    ERC20,
    Ownable,
    DividendPayingTokenInterface,
    DividendPayingTokenOptionalInterface
{
    using SafeMath for uint256;
    using SafeMathUint for uint256;
    using SafeMathInt for int256;
    using Address for address;

    address public rewardToken;

    
    
    
    uint256 internal constant magnitude = 2**128;

    uint256 internal magnifiedDividendPerShare;

    
    
    
    
    
    
    
    
    
    
    
    mapping(address => int256) internal magnifiedDividendCorrections;
    mapping(address => uint256) internal withdrawnDividends;

    uint256 public totalDividendsDistributed;

    constructor(
        address _rewardToken,
        string memory _name,
        string memory _symbol
    ) public ERC20(_name, _symbol) {
        require(_rewardToken.isContract(), "DividendPayingToken: rewardToken illegal");
        rewardToken = _rewardToken;
    }

    function distributeCAKEDividends(uint256 amount) public onlyOwner {
        require(totalSupply() > 0, "DividendPayingToken: totalSupply = 0");
        if (amount > 0) {
            magnifiedDividendPerShare = magnifiedDividendPerShare.add(
                (amount).mul(magnitude) / totalSupply()
            );
            emit DividendsDistributed(msg.sender, amount);
            totalDividendsDistributed = totalDividendsDistributed.add(amount);
        }
    }

    
    
    function withdrawDividend() public virtual override {
        _withdrawDividendOfUser(payable(msg.sender));
    }

    
    
    function _withdrawDividendOfUser(address payable user)
        internal
        returns (uint256)
    {
        uint256 _withdrawableDividend = withdrawableDividendOf(user);
        if (_withdrawableDividend > 0) {
            withdrawnDividends[user] = withdrawnDividends[user].add(
                _withdrawableDividend
            );
            emit DividendWithdrawn(user, _withdrawableDividend);
            
            bytes memory data = abi.encodeWithSelector(
                IERC20(rewardToken).transfer.selector,
                user,
                _withdrawableDividend
            );
            (bool success, bytes memory returndata) = address(rewardToken).call(
                data
            );
            bool result = true;
            if (returndata.length > 0) {
                
                
                result = abi.decode(returndata, (bool));
            }
            
            if (success && result) {
                return _withdrawableDividend;
            } else {
                withdrawnDividends[user] = withdrawnDividends[user].sub(
                    _withdrawableDividend
                );
                return 0;
            }
        }
        return 0;
    }

    
    
    
    function dividendOf(address _owner) public view override returns (uint256) {
        return withdrawableDividendOf(_owner);
    }

    
    
    
    function withdrawableDividendOf(address _owner)
        public
        view
        override
        returns (uint256)
    {
        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);
    }

    
    
    
    function withdrawnDividendOf(address _owner)
        public
        view
        override
        returns (uint256)
    {
        return withdrawnDividends[_owner];
    }

    
    
    
    
    
    function accumulativeDividendOf(address _owner)
        public
        view
        override
        returns (uint256)
    {
        return
            magnifiedDividendPerShare
                .mul(balanceOf(_owner))
                .toInt256Safe()
                .add(magnifiedDividendCorrections[_owner])
                .toUint256Safe() / magnitude;
    }

    
    
    
    
    
    function _transfer(
        address from,
        address to,
        uint256 value
    ) internal virtual override {
        require(false);

        int256 _magCorrection = magnifiedDividendPerShare
            .mul(value)
            .toInt256Safe();
        magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from]
            .add(_magCorrection);
        magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(
            _magCorrection
        );
    }

    
    
    
    
    function _mint(address account, uint256 value) internal override {
        super._mint(account, value);

        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[
            account
        ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());
    }

    
    
    
    
    function _burn(address account, uint256 value) internal override {
        super._burn(account, value);

        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[
            account
        ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());
    }

    function _setBalance(address account, uint256 newBalance) internal {
        uint256 currentBalance = balanceOf(account);

        if (newBalance > currentBalance) {
            uint256 mintAmount = newBalance.sub(currentBalance);
            _mint(account, mintAmount);
        } else if (newBalance < currentBalance) {
            uint256 burnAmount = currentBalance.sub(newBalance);
            _burn(account, burnAmount);
        }
    }
}




pragma solidity >=0.6.0 <0.8.0;

library IterableMapping {
    
    struct Map {
        address[] keys;
        mapping(address => uint256) values;
        mapping(address => uint256) indexOf;
        mapping(address => bool) inserted;
    }

    function get(Map storage map, address key) public view returns (uint256) {
        return map.values[key];
    }

    function getIndexOfKey(Map storage map, address key)
        public
        view
        returns (int256)
    {
        if (!map.inserted[key]) {
            return -1;
        }
        return int256(map.indexOf[key]);
    }

    function getKeyAtIndex(Map storage map, uint256 index)
        public
        view
        returns (address)
    {
        return map.keys[index];
    }

    function size(Map storage map) public view returns (uint256) {
        return map.keys.length;
    }

    function set(
        Map storage map,
        address key,
        uint256 val
    ) public {
        if (map.inserted[key]) {
            map.values[key] = val;
        } else {
            map.inserted[key] = true;
            map.values[key] = val;
            map.indexOf[key] = map.keys.length;
            map.keys.push(key);
        }
    }

    function remove(Map storage map, address key) public {
        if (!map.inserted[key]) {
            return;
        }

        delete map.inserted[key];
        delete map.values[key];

        uint256 index = map.indexOf[key];
        uint256 lastIndex = map.keys.length - 1;
        address lastKey = map.keys[lastIndex];

        map.indexOf[lastKey] = index;
        delete map.indexOf[key];

        map.keys[index] = lastKey;
        map.keys.pop();
    }
}




pragma solidity >=0.6.0 <0.8.0;






contract DividendTracker is Ownable, DividendPayingToken {
    using SafeMath for uint256;
    using SafeMathInt for int256;
    using IterableMapping for IterableMapping.Map;

    IterableMapping.Map private tokenHoldersMap;
    uint256 public lastProcessedIndex;

    mapping(address => bool) public excludedFromDividends;

    mapping(address => uint256) public lastClaimTimes;

    uint256 public claimWait;
    uint256 public minimumTokenBalanceForDividends;

    event ExcludeFromDividends(address indexed account);
    event RecoverFromDividends(address indexed account);
    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);

    event Claim(
        address indexed account,
        uint256 amount,
        bool indexed automatic
    );

    constructor(string memory name_, string memory symbol_, address rewardToken_, uint256 minimumTokenBalanceForDividends_)
        public
        DividendPayingToken(
            rewardToken_,
            name_,
            symbol_
        )
    {
        claimWait = 3600;
        minimumTokenBalanceForDividends = minimumTokenBalanceForDividends_;
    }

    function _transfer(
        address,
        address,
        uint256
    ) internal override {
        require(false, "Dividend_Tracker: No transfers allowed");
    }

    function withdrawDividend() public override {
        require(
            false,
            "Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main BABYTOKEN contract."
        );
    }

    function excludeFromDividends(address account) external onlyOwner {
        if (excludedFromDividends[account]) {
            return;
        }
        excludedFromDividends[account] = true;
        _setBalance(account, 0);
        tokenHoldersMap.remove(account);
        emit ExcludeFromDividends(account);
    }

    function recoverFromDividends(address account) external onlyOwner {
        if (!excludedFromDividends[account]) {
            return;
        }
        excludedFromDividends[account] = false;
        emit RecoverFromDividends(account);
    }

    function isExcludedFromDividends(address account)
        public
        view
        returns (bool)
    {
        return excludedFromDividends[account];
    }

    function updateClaimWait(uint256 newClaimWait) external onlyOwner {
        require(
            newClaimWait >= 3600 && newClaimWait <= 86400,
            "Dividend_Tracker: claimWait must be updated to between 1 and 24 hours"
        );
        require(
            newClaimWait != claimWait,
            "Dividend_Tracker: Cannot update claimWait to same value"
        );
        emit ClaimWaitUpdated(newClaimWait, claimWait);
        claimWait = newClaimWait;
    }

    function updateMinimumTokenBalanceForDividends(uint256 amount)
        external
        onlyOwner
    {
        minimumTokenBalanceForDividends = amount;
    }

    function getLastProcessedIndex() external view returns (uint256) {
        return lastProcessedIndex;
    }

    function getNumberOfTokenHolders() external view returns (uint256) {
        return tokenHoldersMap.keys.length;
    }

    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {
        if (lastClaimTime > block.timestamp) {
            return false;
        }

        return block.timestamp.sub(lastClaimTime) >= claimWait;
    }

    function setBalance(address payable account, uint256 newBalance)
        external
        onlyOwner
    {
        if (excludedFromDividends[account]) {
            return;
        }
        if (newBalance >= minimumTokenBalanceForDividends) {
            _setBalance(account, newBalance);
            tokenHoldersMap.set(account, newBalance);
        } else {
            _setBalance(account, 0);
            tokenHoldersMap.remove(account);
        }
        processAccount(account, true);
    }

    function process(uint256 gas)
        public
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;
        if (numberOfTokenHolders == 0) {
            return (0, 0, lastProcessedIndex);
        }
        uint256 _lastProcessedIndex = lastProcessedIndex;
        uint256 gasUsed = 0;
        uint256 gasLeft = gasleft();
        uint256 iterations = 0;
        uint256 claims = 0;

        while (gasUsed < gas && iterations < numberOfTokenHolders) {
            _lastProcessedIndex++;
            if (_lastProcessedIndex >= tokenHoldersMap.keys.length) {
                _lastProcessedIndex = 0;
            }

            address account = tokenHoldersMap.keys[_lastProcessedIndex];
            if (canAutoClaim(lastClaimTimes[account])) {
                if (processAccount(payable(account), true)) {
                    claims++;
                }
            }

            iterations++;
            uint256 newGasLeft = gasleft();

            if (gasLeft > newGasLeft) {
                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
            }
            gasLeft = newGasLeft;
        }
        lastProcessedIndex = _lastProcessedIndex;
        return (iterations, claims, lastProcessedIndex);
    }

    function processAccount(address payable account, bool automatic)
        public
        onlyOwner
        returns (bool)
    {
        uint256 amount = _withdrawDividendOfUser(account);

        if (amount > 0) {
            lastClaimTimes[account] = block.timestamp;
            emit Claim(account, amount, automatic);
            return true;
        }

        return false;
    }

    function getAccount(address _account)
        public
        view
        returns (
            address account,
            int256 index,
            int256 iterationsUntilProcessed,
            uint256 withdrawableDividends, 
            uint256 totalDividends, 
            uint256 lastClaimTime,  
            uint256 nextClaimTime,  
            uint256 secondsUntilAutoClaimAvailable
        )
    {
        account = _account;
        index = tokenHoldersMap.getIndexOfKey(account);
        iterationsUntilProcessed = -1;
        
        if (index >= 0) {
            if (uint256(index) > lastProcessedIndex) {
                iterationsUntilProcessed = index.sub(
                    int256(lastProcessedIndex)
                );
            } else {
                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >
                    lastProcessedIndex
                    ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)
                    : 0;

                iterationsUntilProcessed = index.add(
                    int256(processesUntilEndOfArray)
                );
            }
        }

        withdrawableDividends = withdrawableDividendOf(account);
        totalDividends = accumulativeDividendOf(account);
        lastClaimTime = lastClaimTimes[account];
        nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;
        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp
            ? nextClaimTime.sub(block.timestamp)
            : 0;
    }

    function getAccountAtIndex(uint256 index)
        public
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        if (index >= tokenHoldersMap.size()) {
            return (address(0), -1, -1, 0, 0, 0, 0, 0);
        }
        address account = tokenHoldersMap.getKeyAtIndex(index);
        return getAccount(account);
    }
}





pragma solidity >=0.6.0 <0.8.0;




/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

   
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

   
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}




pragma solidity >=0.6.0 <0.8.0;










contract MD is ERC20, Ownable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using Address for address;

    uint256 public constant VERSION = 1;

    IUniswapV2Router02 public uniswapV2Router;
    address public uniswapV2Pair;

    bool public swapping;
    DividendTracker public dividendTracker;

    address public rewardToken;
    uint256 public swapTokensAtAmount;

    address public constant HOLE = address(0xdead);
    uint256 public constant PRECISION = 1000;

    
    uint256 public tokenRewardsFee;
    
    uint256 public liquidityFee;
    
    uint256 public marketingFee;
    
    uint256 public inviterFee;
    
    uint256 public destoryFee;
    
    uint256 public swapTotalFees;
    
    uint256 public transferDestoryFee;

    address public marketingWallet;
    
    address public root;
    
    address public liquidityWallet;
    
    uint256 public gasForProcessing;

    
    mapping(address => bool) public isExcludedFromFees;

    
    
    mapping(address => bool) public automatedMarketMakerPairs;

    
    
    uint256 public tradingEnabledTimestamp;
    uint256 public botTime = 5;

    bool public requireTradingSpeedLimit = true;
    uint256 public tradingSpeedLimitValue = 2;

    mapping(address => uint256) public swapLastTime;

    mapping(address => bool) public blockList;
    
    bool public tradingIsEnabled = false;
    
    uint256 public recommendRequire = 0;
    
    uint256 public sellRateLimit;

    
    address public usdt;
    
    
    mapping(address => uint256) public inviterLockTime;
    mapping(address => address) public inviter;
    uint256 public inviterRequireAmount = 0;

    
    uint256 public inviterRequireLockTime;

    
    bool public blockContractDividend = true;
    bool public blockContractTransferTo = true;
    mapping(address => bool) public whiteContractTransferTo;

    address[] private _blockHistory;

    event UpdateDividendTracker(
        address indexed newAddress,
        address indexed oldAddress
    );

    event UpdateUniswapV2Router(
        address indexed newAddress,
        address indexed oldAddress
    );

    event ExcludeFromFees(address indexed account, bool isExcluded);
    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);

    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);

    event LiquidityWalletUpdated(
        address indexed newLiquidityWallet,
        address indexed oldLiquidityWallet
    );

    event GasForProcessingUpdated(
        uint256 indexed newValue,
        uint256 indexed oldValue
    );

    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );

    event SendDividends(uint256 tokensSwapped, uint256 amount);

    event ProcessedDividendTracker(
        uint256 iterations,
        uint256 claims,
        uint256 lastProcessedIndex,
        bool indexed automatic,
        uint256 gas,
        address indexed processor
    );

    event SetInviter(
        address indexed user,
        address indexed inviter,
        uint256 timestamp,
        bool sys
    );

    function _strConcat(string memory _a, string memory _b)
        private
        pure
        returns (string memory)
    {
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        string memory ret = new string(_ba.length + _bb.length);
        bytes memory bret = bytes(ret);
        uint256 k = 0;
        for (uint256 i = 0; i < _ba.length; i++) bret[k++] = _ba[i];
        for (uint256 i = 0; i < _bb.length; i++) bret[k++] = _bb[i];
        return string(ret);
    }

    constructor(
        string memory name_,
        string memory symbol_,
        uint256 totalSupply_,
        address[6] memory addrs, 
        uint256[6] memory feeSettings, 
        uint256 minimumTokenBalanceForDividends_, 
        uint256 recommendRequire_, 
        uint256 sellRateLimit_ 
    ) public ERC20(name_, symbol_) {
        string memory name__ = _strConcat(name_, "_DIVIDEND_TRACKER");
        string memory symbol__ = _strConcat(symbol_, "_DDT");

        rewardToken = addrs[0];
        dividendTracker = new DividendTracker(
            name__,
            symbol__,
            rewardToken,
            minimumTokenBalanceForDividends_ * 10**uint256(decimals())
        );

        marketingWallet = addrs[2];
        usdt = addrs[3];
        root = addrs[4];
        liquidityWallet = addrs[5];

        require(
            msg.sender != marketingWallet,
            "Owner and marketing wallet cannot be the same"
        );

        
        
        tokenRewardsFee = feeSettings[0];
        
        liquidityFee = feeSettings[1];
        
        marketingFee = feeSettings[2];
        
        inviterFee = feeSettings[3];
        
        destoryFee = feeSettings[4];
        
        _updateSwapTotalFees();

        
        transferDestoryFee = feeSettings[5];

        totalSupply_ = totalSupply_ * 10**uint256(decimals());
        swapTokensAtAmount = totalSupply_.mul(2).div(10**6); 

        
        gasForProcessing = 500000;

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(addrs[1]);
        
        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        uniswapV2Pair = _uniswapV2Pair;
        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);

        
        dividendTracker.excludeFromDividends(address(dividendTracker));
        dividendTracker.excludeFromDividends(address(this));
        dividendTracker.excludeFromDividends(owner());
        dividendTracker.excludeFromDividends(address(HOLE));
        dividendTracker.excludeFromDividends(address(_uniswapV2Router));

        
        _excludeFromFees(owner(), true);
        _excludeFromFees(marketingWallet, true);
        _excludeFromFees(root, true);
        _excludeFromFees(address(this), true);

        
        _mint(owner(), totalSupply_);
        recommendRequire = recommendRequire_ * 10**uint256(decimals());
        sellRateLimit = sellRateLimit_;

        
        _setWhiteContractTransferTo(address(uniswapV2Router), true);
        _setWhiteContractTransferTo(address(uniswapV2Pair), true);
    }

    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        require(
            automatedMarketMakerPairs[pair] != value,
            "CCC: Automated market maker pair is already set to that value"
        );
        automatedMarketMakerPairs[pair] = value;

        if (value) {
            dividendTracker.excludeFromDividends(pair);
        }

        emit SetAutomatedMarketMakerPair(pair, value);
    }

    function _excludeFromFees(address account, bool excluded) private {
        if (isExcludedFromFees[account] == excluded) {
            return;
        }
        isExcludedFromFees[account] = excluded;
    }

    function _updateSwapTotalFees() private {
        swapTotalFees = tokenRewardsFee
            .add(liquidityFee)
            .add(marketingFee)
            .add(inviterFee)
            .add(destoryFee);
        require(
            swapTotalFees <= (25 * PRECISION) / 100,
            "Total fee is over 25%"
        );
    }

    function _setWhiteContractTransferTo(address ct, bool value) private {
        whiteContractTransferTo[ct] = value;
    }

    function _addToBlockList(address account, bool status) private {
        if (blockList[account] == status) {
            return;
        }
        blockList[account] = status;
        if (status) {
            _blockHistory.push(account);
            dividendTracker.excludeFromDividends(account);
        } else {
            dividendTracker.recoverFromDividends(account);
        }
    }

    function _addBot(address bot) private {
        _addToBlockList(bot, true);
    }

    receive() external payable {}

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        if (amount == 0) {
            super._transfer(from, to, 0);
            return;
        }

        if (to.isContract()) {
            
            if (blockContractTransferTo) {
                require(
                    whiteContractTransferTo[to] || from == owner(),
                    "CCC: not allow transfer to contract"
                );
            }
        }

        bool isMng = isExcludedFromFees[from] || isExcludedFromFees[to];

        
        if (!isMng) {
            require(!blockList[from] && !blockList[to], "CCC: block");
        }

        
        if (!tradingIsEnabled && !isMng) {
            require(
                !automatedMarketMakerPairs[from] &&
                    !automatedMarketMakerPairs[to],
                "CCC: trading is not enable"
            );
            require(
                !to.isContract(),
                "CCC: trading is not enable, not allow transfer to contract"
            );
        }

        
        if (automatedMarketMakerPairs[to] && !isMng) {
            
            if (sellRateLimit < PRECISION) {
                
                require(
                    amount <= balanceOf(from).mul(sellRateLimit).div(PRECISION)
                );
            }
        }

        
        if (
            tradingIsEnabled &&
            balanceOf(uniswapV2Pair) > 0 &&
            automatedMarketMakerPairs[from] &&
            !isMng &&
            block.timestamp <= tradingEnabledTimestamp + botTime
        ) {
            _addBot(to);
        }

        
        uint256 contractTokenBalance = balanceOf(address(this));
        bool canSwap = contractTokenBalance >= swapTokensAtAmount;
        if (
            canSwap && !swapping && !automatedMarketMakerPairs[from] && !isMng
        ) {
            swapping = true;
            if (marketingFee > 0) {
                
                uint256 marketingTokens = contractTokenBalance
                    .mul(marketingFee)
                    .div(swapTotalFees);
                _swapAndSendToFee(marketingTokens);
            }
            if (liquidityFee > 0) {
                
                uint256 swapTokens = contractTokenBalance.mul(liquidityFee).div(
                    swapTotalFees
                );
                _swapAndLiquify(swapTokens);
            }
            if (tokenRewardsFee > 0) {
                
                uint256 sellTokens = balanceOf(address(this));
                _swapAndSendDividends(sellTokens);
            }
            swapping = false;
        }

        
        bool shouldSetInviter = balanceOf(to) <= inviterRequireAmount &&
            inviter[to] == address(0) &&
            !from.isContract() &&
            !to.isContract() &&
            !blockList[to] && 
            !blockList[from] &&
            amount >= inviterRequireAmount; 

        if (shouldSetInviter) {
            inviter[to] = from;
            inviterLockTime[to] = block.timestamp; 
            emit SetInviter(to, from, block.timestamp, false);
        }

        
        bool isSwap = automatedMarketMakerPairs[from] ||
            automatedMarketMakerPairs[to];

        bool takeFee = !swapping && !isMng;
        if (isSwap) {
            
            address user = automatedMarketMakerPairs[from] ? to : from; 
            if (!user.isContract()) {
                
                if (inviter[user] == address(0)) {
                    inviter[user] = root; 
                    inviterLockTime[user] = block.timestamp;
                    emit SetInviter(user, root, block.timestamp, true);
                } else {
                    if (
                        inviterLockTime[user] >
                        uint256(block.timestamp).sub(inviterRequireLockTime) &&
                        inviter[user] != root
                    ) {
                        
                        inviter[user] = root;
                        inviterLockTime[user] = block.timestamp;
                        emit SetInviter(user, root, block.timestamp, true);
                    }
                }
            }

            
            if (requireTradingSpeedLimit && !isExcludedFromFees[user]) {
                if (block.timestamp > swapLastTime[user]) {
                    if (
                        uint256(block.timestamp).sub(swapLastTime[user]) <=
                        tradingSpeedLimitValue
                    ) {
                        _addBot(user);
                    }
                } else {
                    _addBot(user);
                }
                swapLastTime[user] = block.timestamp;
            }

            
            if (takeFee) {
                uint256 fees = amount.mul(swapTotalFees).div(PRECISION);
                amount = amount.sub(fees);
                super._transfer(from, address(this), fees);
                if (inviterFee > 0) {
                    
                    if (automatedMarketMakerPairs[from]) {
                        
                        _sendRecommend(
                            to,
                            fees.mul(inviterFee).div(swapTotalFees)
                        );
                    } else {
                        
                        swapping = true;
                        _swapAndSendUSDTRecommend(
                            from,
                            fees.mul(inviterFee).div(swapTotalFees)
                        );
                        swapping = false;
                    }
                }
                if (destoryFee > 0) {
                    
                    super._transfer(
                        address(this),
                        HOLE,
                        fees.mul(destoryFee).div(swapTotalFees)
                    );
                }
            }
        } else {
            
            if (takeFee) {
                if (transferDestoryFee > 0) {
                    uint256 fees = amount.mul(transferDestoryFee).div(
                        PRECISION
                    );
                    amount = amount.sub(fees);
                    super._transfer(from, HOLE, fees);
                }
            }
        }
        super._transfer(from, to, amount);
        
        
        if (blockContractDividend && from.isContract()) {
            if (!dividendTracker.isExcludedFromDividends(from)) {
                dividendTracker.excludeFromDividends(from);
            }
        } else if (blockContractDividend && to.isContract()) {
            if (!dividendTracker.isExcludedFromDividends(to)) {
                dividendTracker.excludeFromDividends(to);
            }
        }

        
        try
            dividendTracker.setBalance(payable(from), balanceOf(from))
        {} catch {}
        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}

        if (!swapping) {
            uint256 gas = gasForProcessing;

            try dividendTracker.process(gas) returns (
                uint256 iterations,
                uint256 claims,
                uint256 lastProcessedIndex
            ) {
                emit ProcessedDividendTracker(
                    iterations,
                    claims,
                    lastProcessedIndex,
                    true,
                    gas,
                    tx.origin
                );
            } catch {}
        }
    }

    function _swapTokensForUsdt(uint256 tokens) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = address(uniswapV2Router.WETH());
        path[2] = address(usdt);

        _approve(address(this), address(uniswapV2Router), tokens);

        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokens,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function _swapTokensForEth(uint256 tokens) private {
        
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokens);

        
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokens,
            0, 
            path,
            address(this),
            block.timestamp
        );
    }

    function _swapAndSendToFee(uint256 tokens) private {
        uint256 initialBalance = IERC20(usdt).balanceOf(address(this));
        _swapTokensForUsdt(tokens);
        uint256 newBalance = IERC20(usdt).balanceOf(address(this)).sub(
            initialBalance
        );
        IERC20(usdt).safeTransfer(marketingWallet, newBalance);
    }

    function _addLiquidity(uint256 tokens, uint256 ethers) private {
        
        _approve(address(this), address(uniswapV2Router), tokens);

        
        uniswapV2Router.addLiquidityETH{value: ethers}(
            address(this),
            tokens,
            0, 
            0, 
            liquidityWallet,
            block.timestamp
        );
    }

    function _swapAndLiquify(uint256 tokens) private {
        
        uint256 half = tokens.div(2);
        uint256 otherHalf = tokens.sub(half);

        
        
        
        
        uint256 initialBalance = address(this).balance;

        
        _swapTokensForEth(half);
        

        
        uint256 newBalance = address(this).balance.sub(initialBalance);

        
        _addLiquidity(otherHalf, newBalance);

        emit SwapAndLiquify(half, newBalance, otherHalf);
    }

    function _swapTokensForRewardToken(uint256 tokens) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = address(uniswapV2Router.WETH());
        path[2] = address(rewardToken);

        _approve(address(this), address(uniswapV2Router), tokens);
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokens,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function _swapAndSendDividends(uint256 tokens) private {
        _swapTokensForRewardToken(tokens);
        uint256 dividends = IERC20(rewardToken).balanceOf(address(this));
        IERC20(rewardToken).safeTransfer(address(dividendTracker), dividends);
        dividendTracker.distributeCAKEDividends(dividends);
        emit SendDividends(tokens, dividends);
    }

    function _swapAndSendUSDTRecommend(address from, uint256 tokens) private {
        
        if (balanceOf(address(this)) < tokens) {
            return;
        }
        uint256 initialBalance = IERC20(usdt).balanceOf(address(this));
        _swapTokensForUsdt(tokens);
        uint256 newBalance = IERC20(usdt).balanceOf(address(this)).sub(
            initialBalance
        );
        uint256 use = 0;
        address index = inviter[from];
        for (uint256 i = 1; i <= 5; i++) {
            if (index == address(0)) {
                break;
            }
            if (balanceOf(index) < recommendRequire || blockList[index]) {
                index = inviter[index];
                continue;
            }
            uint256 reward = newBalance.mul(1).div(6);
            if (i == 1) {
                reward = newBalance.mul(2).div(6);
            }
            if (IERC20(usdt).balanceOf(address(this)) >= reward) {
                IERC20(usdt).safeTransfer(index, reward);
            }
            use = use.add(reward);
            index = inviter[index];
        }
        
        if (newBalance > use) {
            uint256 tmp = newBalance.sub(use);
            if (IERC20(usdt).balanceOf(address(this)) >= tmp) {
                IERC20(usdt).safeTransfer(root, tmp);
            }
        }
    }

    function _sendRecommend(address from, uint256 tokens) private {
        
        if (balanceOf(address(this)) < tokens) {
            return;
        }
        uint256 use = 0;
        address index = inviter[from];
        for (uint256 i = 1; i <= 5; i++) {
            if (index == address(0)) {
                break;
            }
            if (balanceOf(index) < recommendRequire || blockList[index]) {
                index = inviter[index];
                continue;
            }
            uint256 reward = tokens.mul(1).div(6);
            if (i == 1) {
                reward = tokens.mul(2).div(6);
            }
            if (balanceOf(address(this)) >= reward) {
                use = use.add(reward);
                super._transfer(address(this), index, reward);
            }
            index = inviter[index];
        }
        
        if (tokens > use) {
            uint256 tmp = tokens.sub(use);
            if (balanceOf(address(this)) >= tmp) {
                super._transfer(address(this), root, tmp);
            }
        }
    }

    
    function strConcat(string memory _a, string memory _b)
        external
        pure
        returns (string memory)
    {
        return _strConcat(_a, _b);
    }

    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {
        swapTokensAtAmount = amount;
    }

    function updateDividendTracker(address newAddress) external onlyOwner {
        require(
            newAddress != address(dividendTracker),
            "CCC: The dividend tracker already has that address"
        );

        DividendTracker newDividendTracker = DividendTracker(
            payable(newAddress)
        );

        require(
            newDividendTracker.owner() == address(this),
            "CCC: The new dividend tracker must be owned by the CCC token contract"
        );

        newDividendTracker.excludeFromDividends(address(newDividendTracker));
        newDividendTracker.excludeFromDividends(address(this));
        newDividendTracker.excludeFromDividends(owner());
        newDividendTracker.excludeFromDividends(address(uniswapV2Router));
        newDividendTracker.excludeFromDividends(address(HOLE));
        emit UpdateDividendTracker(newAddress, address(dividendTracker));

        dividendTracker = newDividendTracker;
    }

    function updateUniswapV2Router(address newAddress) external onlyOwner {
        require(
            newAddress != address(uniswapV2Router),
            "CCC: The router already has that address"
        );
        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));
        uniswapV2Router = IUniswapV2Router02(newAddress);
        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())
            .createPair(address(this), uniswapV2Router.WETH());
        uniswapV2Pair = _uniswapV2Pair;
    }

    function excludeFromFees(address account, bool excluded)
        external
        onlyOwner
    {
        _excludeFromFees(account, excluded);
        emit ExcludeFromFees(account, excluded);
    }

    function excludeMultipleAccountsFromFees(
        address[] calldata accounts,
        bool excluded
    ) external onlyOwner {
        for (uint256 i = 0; i < accounts.length; i++) {
            _excludeFromFees(accounts[i], excluded);
        }
        emit ExcludeMultipleAccountsFromFees(accounts, excluded);
    }

    function setAutomatedMarketMakerPair(address pair, bool value)
        external
        onlyOwner
    {
        require(
            pair != uniswapV2Pair,
            "CCC: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs"
        );

        _setAutomatedMarketMakerPair(pair, value);
    }

    function updateGasForProcessing(uint256 newValue) external onlyOwner {
        require(
            newValue >= 200000 && newValue <= 1000000,
            "CCC: gasForProcessing must be between 200,000 and 1,000,000"
        );
        require(
            newValue != gasForProcessing,
            "CCC: Cannot update gasForProcessing to same value"
        );
        emit GasForProcessingUpdated(newValue, gasForProcessing);
        gasForProcessing = newValue;
    }

    function updateClaimWait(uint256 claimWait) external onlyOwner {
        dividendTracker.updateClaimWait(claimWait);
    }

    function getClaimWait() external view returns (uint256) {
        return dividendTracker.claimWait();
    }

    function updateMinimumTokenBalanceForDividends(uint256 amount)
        external
        onlyOwner
    {
        dividendTracker.updateMinimumTokenBalanceForDividends(amount);
    }

    function getMinimumTokenBalanceForDividends()
        external
        view
        returns (uint256)
    {
        return dividendTracker.minimumTokenBalanceForDividends();
    }

    function getTotalDividendsDistributed() external view returns (uint256) {
        return dividendTracker.totalDividendsDistributed();
    }

    function withdrawableDividendOf(address account)
        external
        view
        returns (uint256)
    {
        return dividendTracker.withdrawableDividendOf(account);
    }

    function dividendTokenBalanceOf(address account)
        external
        view
        returns (uint256)
    {
        return dividendTracker.balanceOf(account);
    }

    function excludeFromDividends(address account) external onlyOwner {
        dividendTracker.excludeFromDividends(account);
    }

    function recoverFromDividends(address account) external onlyOwner {
        dividendTracker.recoverFromDividends(account);
    }

    function isExcludedFromDividends(address account)
        external
        view
        returns (bool)
    {
        return dividendTracker.isExcludedFromDividends(account);
    }

    function getAccountDividendsInfo(address account)
        external
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        return dividendTracker.getAccount(account);
    }

    function getAccountDividendsInfoAtIndex(uint256 index)
        external
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        return dividendTracker.getAccountAtIndex(index);
    }

    function processDividendTracker(uint256 gas) external {
        (
            uint256 iterations,
            uint256 claims,
            uint256 lastProcessedIndex
        ) = dividendTracker.process(gas);
        emit ProcessedDividendTracker(
            iterations,
            claims,
            lastProcessedIndex,
            false,
            gas,
            tx.origin
        );
    }

    function claim() external {
        dividendTracker.processAccount(payable(msg.sender), false);
    }

    function getLastProcessedIndex() external view returns (uint256) {
        return dividendTracker.getLastProcessedIndex();
    }

    function getNumberOfDividendTokenHolders() external view returns (uint256) {
        return dividendTracker.getNumberOfTokenHolders();
    }

    function setFee(uint256 index, uint256 value) external onlyOwner {
        if (index == 0) {
            tokenRewardsFee = value;
        } else if (index == 1) {
            liquidityFee = value;
        } else if (index == 2) {
            marketingFee = value;
        } else if (index == 3) {
            inviterFee = value;
        } else if (index == 4) {
            destoryFee = value;
        } else {
            return;
        }
        _updateSwapTotalFees();
    }

    function setTransferDestoryFee(uint256 value) external onlyOwner {
        transferDestoryFee = value;
    }

    function setTradingEnabled(bool flag, uint256 tradingEnabledTimestamp_)
        external
        onlyOwner
    {
        tradingIsEnabled = flag;
        if (tradingIsEnabled) {
            if (tradingEnabledTimestamp_ == 0) {
                tradingEnabledTimestamp = block.timestamp;
            } else {
                tradingEnabledTimestamp = tradingEnabledTimestamp_;
            }
        }
    }

    function setRecommendRequire(uint256 value) external onlyOwner {
        recommendRequire = value;
    }

    function setSellRateLimit(uint256 value) external onlyOwner {
        sellRateLimit = value;
    }

    function setAddrsParams(
        address usdt_,
        address marketingWallet_,
        address root_,
        address liquidityWallet_
    ) external onlyOwner {
        if (usdt != usdt_) {
            usdt = usdt_;
        }
        if (marketingWallet != marketingWallet_) {
            marketingWallet = marketingWallet_;
        }
        if (root != root_) {
            root = root_;
        }
        if (liquidityWallet != liquidityWallet_) {
            liquidityWallet = liquidityWallet_;
        }
    }

    function addToBlockList(address account, bool status) external onlyOwner {
        _addToBlockList(account, status);
    }

    function addMultipleToBlockList(address[] calldata accounts, bool status)
        external
        onlyOwner
    {
        for (uint256 i = 0; i < accounts.length; i++) {
            _addToBlockList(accounts[i], status);
        }
    }

    function setBlockContract(uint256 index, bool value) external onlyOwner {
        if (index == 0) {
            blockContractTransferTo = value;
        } else if (index == 1) {
            blockContractDividend = value;
        }
    }

    function setWhiteContractTransferTo(address ct, bool value)
        external
        onlyOwner
    {
        _setWhiteContractTransferTo(ct, value);
    }

    function setInviterRequireAmount(uint256 value) external onlyOwner {
        inviterRequireAmount = value;
    }

    function setRequireTradingSpeed(
        bool status,
        uint256 value,
        uint256 botTime_
    ) external onlyOwner {
        requireTradingSpeedLimit = status;
        tradingSpeedLimitValue = value;
        botTime = botTime_;
    }

    function blockHistory(uint256 start, uint256 length)
        external
        view
        onlyOwner
        returns (address[] memory)
    {
        address[] memory returndata = new address[](length);
        uint256 end = start + length;
        if (start >= _blockHistory.length) {
            start = _blockHistory.length - 1;
        }
        if (end > _blockHistory.length) {
            end = _blockHistory.length;
        }
        uint256 j = 0;
        for (uint256 i = start; i < end; i++) {
            returndata[j] = _blockHistory[i];
        }
        return returndata;
    }
}