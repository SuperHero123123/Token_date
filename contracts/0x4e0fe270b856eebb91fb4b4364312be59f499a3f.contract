{{
  "language": "Solidity",
  "sources": {
    "contracts/DAFITokenBSC.sol": {
      "content": "\n\npragma solidity 0.8.9;\nimport \"./standardtoken.sol\";\nimport \"./ownable.sol\";\n\n\n\n\ncontract DAFITokenBSC is StandardToken, Ownable {\n    string public constant _name = \"DAFI Token\";\n    string public constant _symbol = \"DAFI\";\n    uint256 public constant _decimals = 18;\n\n    uint256 public immutable maxSupply;\n\n\n    constructor(address _owner, address _bridge)  Ownable(_owner,_bridge) {\n        maxSupply = 2250000000 * 10**_decimals;\n    }\n\n\n    function mint(uint256 _value, address _beneficiary) external onlyBridge {\n        require(_beneficiary != address(0),\"Beneficiary cannot be ZERO ADDRESS\");\n        require(_value > 0,\"value should be more than 0\");\n        require((_value + _totalSupply) <= maxSupply, \"Minting amount exceeding max limit\");\n        balances[_beneficiary] = balances[_beneficiary] + _value;\n        unchecked {\n            _totalSupply = _totalSupply + _value;\n            \n        }\n        \n\n        emit Transfer(address(0), _beneficiary, _value);\n    }\n\n    function burnFrom(uint256 _value, address _beneficiary) external onlyBridge {\n        require(_beneficiary != address(0),\"Beneficiary cannot be ZERO ADDRESS\");\n        require(balanceOf(_beneficiary) >= _value, \"User does not have sufficient tokens to burn\");\n        require(_value <= allowed[_beneficiary][msg.sender], \"user did not approve the bridge to burn the said amount.\");\n\n        _totalSupply = _totalSupply - _value;\n        balances[_beneficiary] = balances[_beneficiary] - _value;\n        allowed[_beneficiary][msg.sender] = allowed[_beneficiary][msg.sender] - _value;\n\n        emit Transfer(_beneficiary, address(0), _value);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public pure returns (uint256) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/standardtoken.sol": {
      "content": "pragma solidity 0.8.9;\nimport \"./basictoken.sol\";\nimport \"./erc20.sol\";\n\ncontract StandardToken is ERC20, BasicToken {\n  mapping(address => mapping(address => uint256)) internal allowed;\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) public returns (bool) {\n    require(_to != address(0), \"To cannot be ZERO ADDRESS\");\n    require(_from != address(0), \"From cannot be Address 0\");\n    require(_value <= balances[_from], \"Insufficient Balance\");\n    require(\n      _value <= allowed[_from][msg.sender],\n      \"msg sender not approved of this amount\"\n    );\n    unchecked {\n      balances[_from] = balances[_from] - _value;\n      allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n    }\n\n    balances[_to] = balances[_to] + _value;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _value)\n    public\n    override\n    returns (bool)\n  {\n    require(_spender != address(0), \"Spender cannot be ZERO ADDRESS\");\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  function increaseApproval(address _spender, uint256 _addedValue)\n    public\n    returns (bool)\n  {\n    require(_spender != address(0), \"Spender cannot be ZERO ADDRESS\");\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint256 _subtractedValue)\n    public\n    returns (bool)\n  {\n    require(_spender != address(0), \"Spender cannot be ZERO ADDRESS\");\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      unchecked { allowed[msg.sender][_spender] = oldValue - _subtractedValue; }\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n}\n"
    },
    "contracts/ownable.sol": {
      "content": "pragma solidity 0.8.9;\n\n\n contract Ownable {\n    address public owner;\n    address public bridge;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event BridgeChanged(address indexed previousBridge, address indexed newBridge);\n\n    constructor(address _owner,address _bridge)  {\n        owner = _owner;\n        bridge = _bridge;\n    }\n    \n\n    modifier onlyOwner() {\n        require(msg.sender == owner,\"Only Owner can call this function\");\n        _;\n    }\n    modifier onlyBridge() {\n        require(msg.sender == bridge, \"only Bridge can call this function\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0),\"new owner cannot be Address 0\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function changeBridge(address newBridgeAddress) public onlyOwner {\n        require(newBridgeAddress != address(0),\"new owner cannot be address 0\");\n        emit BridgeChanged(bridge, newBridgeAddress);\n        bridge = newBridgeAddress;\n    }\n}"
    },
    "contracts/basictoken.sol": {
      "content": "\npragma solidity 0.8.9;\nimport \"./erc20basic.sol\";\n contract BasicToken is ERC20Basic {\n\n    mapping(address => uint256) internal balances;\n\n    uint256 internal _totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public override returns (bool) {\n        require(_to != address(0),\"Cannot call transfer with to as ZERO ADDRESS\");\n        require(_value <= balances[msg.sender],\"cannot transfer amount more than your balance\");\n        unchecked {\n            balances[msg.sender] = balances[msg.sender] - _value;\n            \n        }\n        \n        balances[_to] = balances[_to] + _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}"
    },
    "contracts/erc20.sol": {
      "content": "pragma solidity 0.8.9;\nimport \"./erc20basic.sol\";\n\n\n interface ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/erc20basic.sol": {
      "content": "pragma solidity 0.8.9;\n\n\n\n interface ERC20Basic {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}